[
  {
    "updated": "2025-05-15T00:48:00.000+00:00",
    "Quadrant": "工具",
    "Description": "LLM Guardrails 是一套用于防止大语言模型（LLMs）生成有害、使人误解或不相关内容的指南、政策或过滤 器。Guardrails 也可用于保护 LLM 应用免受恶意用户通过操纵输入等技术对其滥用。它们通过为模型设定边界 来作为安全网，确保内容的处理和生成在可控范围内。在这一领域中，诸如 NeMo Guardrails 、Guardrails AI 和 Aporia Guardrails 等框架已经逐渐崭露头角，并被我们的团队认为非常有用。我们建议每个 LLM 应用都应 设置相应的安全护栏，并且不断改进其规则和政策。这对于构建负责任和值得信赖的 LLM 聊天应用至关重要\n[NeMo Guardrails \\| Technology Radar \\| Thoughtworks China](https://www.thoughtworks.com/cn/radar/tools/nemo-guardrails)\n[GitHub - guardrails-ai/guardrails: Adding guardrails to large language models.](https://github.com/guardrails-ai/guardrails)\n[Security](https://www.aporia.com/ai-security/)\n",
    "Tags": [],
    "ID": "64",
    "LastChange": "72",
    "Aliases": "",
    "Ring": "assess",
    "Name": "LLM Guardrails",
    "notion_page_id": "1f40aea5-43e6-815b-bb77-cb077aec7ae1"
  },
  {
    "updated": "2025-05-15T00:47:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "LiteLLM 是一个用于无缝集成各种大语言模型（LLM）提供商 API 的库，通过 OpenAI API 格式 交互。它支持多 种 提供方和模型，并为文本生成、嵌入和图像生成提供统一的接口。LiteLLM 简化了集成过程，通过匹配每个 提供商的特定端点要求来翻译输入。它还提供了实现生产应用中所需的操作功能的框架，如缓存、日志记录、 速率限制和负载均衡，从而确保不同 LLM 的一致操作。我们的团队使用 LiteLLM 来轻松切换各种模型，这在 模型快速演变的今天尤为必要。然而，值得注意的是，不同模型在相同提示下的响应会有所不同，这表明仅一 致的调用方式可能不足以优化生成性能。此外，每个模型对附加功能的实现方式也各不相同，单一接口可能无 法满足所有需求。例如，我们的一个团队在通过 LiteLLM 代理 AWS Bedrock 模型时，难以充分利用其函数调 用功能。\n\n[GitHub - BerriAI/litellm: Python SDK, Proxy Server (LLM Gateway) to call 100+ LLM APIs in OpenAI format - \\[Bedrock, Azure, OpenAI, VertexAI, Cohere, Anthropic, Sagemaker, HuggingFace, Replicate, Groq\\]](https://github.com/BerriAI/litellm)",
    "Tags": [],
    "ID": "63",
    "LastChange": "71",
    "Aliases": "",
    "Ring": "assess",
    "Name": "LiteLLM",
    "notion_page_id": "1f40aea5-43e6-81eb-b20b-f816da1b366b"
  },
  {
    "updated": "2025-05-15T00:46:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "当我们作为终端用户使用大语言模型（LLM）聊天机器人时，它们通常会返回给我们一个非结构化的自然语言答 案。在构建超越聊天机器人的生成 AI 应用时，请求 LLM 以 JSON、YAML 或其他格式返回结构化答案并在应 用中解析和使用该响应可能非常有用。然而，由于 LLM 是非确定性的，它们可能并不总是按照我们要求的方式 执行。Instructor 是一个可以帮助我们请求 从 LLMs 获取结构化输出 的库。您可以定义预期的输出结构，并 在 LLM 未返回您要求的结构时配置重试。由于与 LLM 进行交互时，最佳的终端用户体验往往是将结果流式传 输给他们，而不是等待完整响应，Instructor 还可以处理从流中解析部分结构的任务。\n[GitHub - instructor-ai/instructor: structured outputs for llms](https://github.com/jxnl/instructor)",
    "Tags": [],
    "ID": "62",
    "LastChange": "70",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Instructor",
    "notion_page_id": "1f40aea5-43e6-814f-b36c-f9539914f6e8"
  },
  {
    "updated": "2025-05-15T00:46:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "使用 Playwright，您可以编写在 Chrome、Firefox 和 WebKit 中运行的端到端测试。 通过使用 Chrome 开发 者工具（DevTools）协议（CDP），Playwright 可以提供新功能并消除 WebDriver 中出现的许多问题。 基于 Chromium 的浏览器直接实现了 CDP。不过，为了支持 Firefox 和 Webkit，Playwright 团队不得不向这些浏览 器提交补丁，这有时可能会限制框架。 \n\nPlaywright 的功能包括：内置自动等待，这使得测试更可靠、更易于理解； 浏览器上下文，可让您测试跨标签 页的持久会话是否正常工作；以及模拟通知、地理位置和黑暗模式设置的能力。 Playwright 为测试套件带来的 稳定性给我们的团队留下了深刻印象，并且喜欢它可以并行运行测试以更快地获得反馈。 Playwright 的其他特 色包括更好地支持懒加载和追踪。 尽管 Playwright 有一些局限性（例如，组件支持目前处于实验阶段），但我 们的团队认为它是首选的测试框架，甚至在某些情况下会从 Cypress 和 Puppeteer 上迁移过来。\n[Fast and reliable end-to-end testing for modern web apps \\| Playwright](https://playwright.dev/)\n",
    "Tags": [],
    "ID": "61",
    "LastChange": "69",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Playwright",
    "notion_page_id": "1f40aea5-43e6-81cb-b062-fca754f1c9b4"
  },
  {
    "updated": "2025-05-15T00:44:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "[**LangGraph**](https://github.com/langchain-ai/langgraph) 是一款面向基于 LLM 的[多 agent 应用](https://www.thoughtworks.com/zh-cn/radar/techniques/llm-powered-autonomous-agents)构建的编排（Orchestration）框架。与抽象程度较高的 [LangChain](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/langchain) 相比，它提供了更底层的节点（Nodes）和边（Edges）等基本原语，允许开发者精细地控制 agent 工作流、记忆管理与状态持久化。这种基于图的设计使工作流更加可控且易于定制，使得在生产级应用中的调试、扩展和维护变得更加容易。尽管其学习曲线较陡，但 LangGraph 凭借其轻量化与模块化设计，在开发 agent 应用时展现出了强大的灵活性和扩展性。",
    "Tags": [],
    "ID": "60",
    "LastChange": "68",
    "Aliases": "",
    "Ring": "assess",
    "Name": "LangGraph",
    "notion_page_id": "1f40aea5-43e6-818d-9bb6-d8817c30ab6c"
  },
  {
    "updated": "2025-05-06T05:42:00.000+00:00",
    "Quadrant": "工具",
    "Description": "1Password 是一款跨平台的密码管理器，用于安全存储和自动填充密码、信用卡、身份信息、双因素验证码等敏感数据，提升数字账户安全性与使用效率。",
    "Tags": [],
    "ID": "59",
    "LastChange": "62",
    "Aliases": "",
    "Ring": "assess",
    "Name": "1Password",
    "notion_page_id": "1eb0aea5-43e6-8109-b312-cc0949b1596b"
  },
  {
    "updated": "2025-05-06T05:42:00.000+00:00",
    "Quadrant": "工具",
    "Description": "OneKey 是一款开源的**加密货币硬件钱包与软件生态系统**，用于安全管理比特币、以太坊等多种区块链资产。其核心目标是为用户提供**私钥自持、安全可控**的钱包体验。",
    "Tags": [],
    "ID": "58",
    "LastChange": "63",
    "Aliases": "",
    "Ring": "assess",
    "Name": "OneKey",
    "notion_page_id": "1eb0aea5-43e6-8131-9334-dee3f03cd075"
  },
  {
    "updated": "2025-05-06T05:42:00.000+00:00",
    "Quadrant": "技术",
    "Description": "RPA 是一种通过软件机器人模拟人类在图形界面上的操作，实现**重复性、规则性任务自动化**的技术，广泛应用于企业流程自动化。",
    "Tags": [],
    "ID": "57",
    "LastChange": "64",
    "Aliases": "",
    "Ring": "assess",
    "Name": "RPA",
    "notion_page_id": "1eb0aea5-43e6-8101-a543-cdac0a823791"
  },
  {
    "updated": "2025-05-06T02:35:00.000+00:00",
    "Quadrant": "技术",
    "Description": "https://martinfowler.com/bliki/RefinementCodeReview.html",
    "Tags": [],
    "ID": "56",
    "LastChange": "61",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Code Review",
    "notion_page_id": "1eb0aea5-43e6-8187-b070-f0abf103a260"
  },
  {
    "updated": "2025-05-06T02:32:00.000+00:00",
    "Quadrant": "技术",
    "Description": "## 一、定义\n\n演化式架构是一种支持系统在不断变化中**持续适应和演进**的架构设计方式，强调**适应性优先于确定性**，以应对快速变化的业务和技术需求。\n\n---\n\n## 二、核心特征\n\n- 🔄 **持续变更友好**：架构设计预设变化，而非抗拒变化  \n- 🧪 **支持实验**：架构允许并鼓励在局部试验新方案  \n- 🧱 **架构守护（Fitness Functions）**：自动化指标确保演化过程中不偏离关键目标（如安全、性能）  \n- 🧠 **基于反馈**：架构调整基于实际运行反馈，而非一次性设计\n\n---\n\n## 三、设计原则\n\n| 原则             | 说明                                 |\n|------------------|--------------------------------------|\n| 最小耦合         | 降低模块间依赖，便于独立演进         |\n| 可替换性         | 任意组件都能被替换或重构              |\n| 自动化评估机制   | 使用 Fitness Functions 衡量系统质量   |\n| 版本化与渐进式交付 | 支持灰度发布、A/B 测试、金丝雀发布等   |\n| 实验驱动         | 技术选型基于快速试验与反馈循环        |\n\n---\n\n## 四、适用场景\n\n- 快速迭代的产品型企业  \n- 架构需频繁调整（如云原生、微服务架构）  \n- 希望实现长期技术可持续性的系统\n\n---\n\n## 五、相关概念\n\n- 微服务架构（Microservices）  \n- 架构守护机制（Fitness Functions）  \n- 可演化系统设计（Evolvability）  \n- 架构决策记录（ADR）\n\n---\n\n## 六、参考资料\n\n- *Building Evolutionary Architectures*（Neal Ford 等著）  \n- ThoughtWorks 技术雷达相关条目  \n- https://evolutionaryarchitecture.com/\n\n",
    "Tags": [],
    "ID": "55",
    "LastChange": "60",
    "Aliases": "",
    "Ring": "assess",
    "Name": "演化式架构",
    "notion_page_id": "1eb0aea5-43e6-813d-acb4-ed02135aa520"
  },
  {
    "updated": "2025-05-06T01:41:00.000+00:00",
    "Quadrant": "平台",
    "Description": "树莓派（Raspberry Pi）是一款低成本、体积小巧的单板计算机，由英国树莓派基金会开发，旨在推动编程与计算机教育普及。它搭载 ARM 架构处理器，支持运行 Linux 系统，可通过 GPIO 接口连接各种传感器与模块，广泛应用于编程学习、电子制作、智能家居、物联网（IoT）等领域。树莓派以其灵活性、能耗低、社区活跃而受到开发者与创客喜爱。",
    "Tags": [],
    "ID": "54",
    "LastChange": "57",
    "Aliases": "",
    "Ring": "assess",
    "Name": "树莓派",
    "notion_page_id": "1eb0aea5-43e6-8161-b000-e44a209663ff"
  },
  {
    "updated": "2025-05-06T01:42:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Arduino 是一个开源电子原型平台，由可编程硬件（如开发板）和简洁易用的软件（Arduino IDE）组成，适合快速开发交互式项目。它通过 C/C++ 语言进行编程，支持连接各种传感器、执行器与模块，广泛应用于创客教育、物联网、机器人和自动化控制等领域。Arduino 强调易用性和可扩展性，拥有庞大的社区和丰富的库资源，适合从初学者到专业开发者使用。",
    "Tags": [],
    "ID": "53",
    "LastChange": "58",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Arduino",
    "notion_page_id": "1eb0aea5-43e6-813b-ab86-f2892e6465df"
  },
  {
    "updated": "2025-05-06T01:46:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[**OpenTelemetry**](https://opentelemetry.io/) 正迅速成为可观察性领域的行业标准。随着 [OpenTelemetry 协议 (OTLP)](https://opentelemetry.io/docs/specs/otel/protocol/) 规范的发布，行业内有了一个标准化的方式来处理追踪 (traces)、指标 (metrics) 和日志 (logs)。这减少了在监控分布式解决方案和满足互操作性需求时的多重集成或主要代码重构的需要。随着 OpenTelemetry 扩展对日志和性能分析的支持，OTLP 为所有遥测数据提供了一个一致的传输格式，简化了应用的仪表化过程，使全栈可观察性对于微服务架构更加易于实现且具有可扩展性。OTLP 已被诸如 [Datadog](https://docs.datadoghq.com/es/opentelemetry/interoperability/otlp_ingest_in_the_agent/?tab=host) 、[New Relic](https://docs.newrelic.com/docs/opentelemetry/get-started/collector-processing/opentelemetry-collector-processing-intro/) 和 [Grafana](https://grafana.com/docs/grafana-cloud/send-data/otlp/) 等供应商采纳，帮助企业构建灵活的、与供应商无关的可观察性技术栈，避免被锁定在专有解决方案中。OTLP 支持 gzip 和 zstd 压缩，大幅减少遥测数据的大小并降低带宽使用——这对于处理高遥测数据量的环境尤为关键。为了支持长期发展，OTLP 确保 OpenTelemetry 保持强大且面向未来的标准，巩固了其作为遥测传输事实标准的地位。",
    "Tags": [],
    "ID": "52",
    "LastChange": "59",
    "Aliases": "",
    "Ring": "assess",
    "Name": "OpenTelemetry",
    "notion_page_id": "1eb0aea5-43e6-8116-8d05-d0b058429eb9"
  },
  {
    "updated": "2025-05-06T01:38:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[Home Assistant](https://www.home-assistant.io/) 是一个开源的家庭自动化平台，支持数千种智能设备和服务的接入与控制。它基于 Python 构建，支持本地部署，强调隐私、安全与离线运行能力。用户可通过 YAML 配置自动化逻辑，或使用可视化界面创建规则，实现设备联动、状态感知和智能场景控制。Home Assistant 拥有活跃的社区和插件生态，适合高级用户进行深度定制，也适合初学者搭建稳定高效的智能家居系统。",
    "Tags": [],
    "ID": "51",
    "LastChange": "56",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Home Assistant",
    "notion_page_id": "1eb0aea5-43e6-8183-8cdd-dcc45846bbd0"
  },
  {
    "updated": "2025-05-06T01:27:00.000+00:00",
    "Quadrant": "平台",
    "Description": "MongoDB 是一个开源的 NoSQL 数据库，采用文档型结构（BSON 格式）存储数据，支持灵活的字段、强大的查询能力和高扩展性，常用于处理大数据和快速迭代的应用场景。",
    "Tags": [],
    "ID": "50",
    "LastChange": "55",
    "Aliases": "",
    "Ring": "assess",
    "Name": "MongoDB",
    "notion_page_id": "1eb0aea5-43e6-8178-ad7b-d357376b4024"
  },
  {
    "updated": "2025-05-06T01:07:00.000+00:00",
    "Quadrant": "工具",
    "Description": "# 🧩 卡诺图（Karnaugh Map）简洁笔记\n\n## 一、定义\n\n卡诺图是一种用于**简化布尔代数表达式**的图形工具，可视化地帮助识别和合并逻辑表达式中的“最小项”或“最大项”。\n\n---\n\n## 二、核心目的\n\n- ✅ 简化布尔表达式（减少逻辑门数量）\n- ✅ 提高电路设计效率\n- ✅ 降低错误率\n\n---\n\n## 三、基本结构\n\n- 每个单元格代表一个 **最小项**（对应一个输入组合）\n- 使用**格雷码（Gray Code）**排序，以保证相邻单元只改变一位变量\n- 值为 `1` 的格表示输出为真（用于最小项合并）\n\n---\n\n## 四、使用流程\n\n1. **确定变量个数**（2~4 个最常见，最大支持6个）\n2. **绘制表格结构**（列和行用格雷码编号）\n3. **填入值**（根据真值表将输出为 `1` 的格填入）\n4. **圈出相邻的 1 组**（2ⁿ个一组：1、2、4、8...）\n5. **写出化简后的表达式**\n\n---\n\n## 五、示例（3变量）\n\n变量：A, B, C\n\n| AB＼C | 0 | 1 |\n|------|---|---|\n| 00   | 1 | 1 |\n| 01   | 0 | 1 |\n| 11   | 0 | 0 |\n| 10   | 1 | 1 |\n\n→ 合并相邻的 `1` 组，推导最简 SOP 表达式\n\n---\n\n## 六、适用范围与限制\n\n- ✅ 小规模逻辑简化（2~4变量最直观）\n- ⚠️ 对变量数较多（>5）时不易手工处理，需用算法或软件（如Quine-McCluskey）\n\n---\n\n## 七、工具推荐\n\n- 手工绘制（纸笔、白板）\n- 数字电路设计软件：Logisim、Digital Works\n- 在线工具：[kmaptools.com](https://www.kmaptools.com/)\n\n",
    "Tags": [],
    "ID": "49",
    "LastChange": "54",
    "Aliases": "",
    "Ring": "assess",
    "Name": "卡诺图",
    "notion_page_id": "1eb0aea5-43e6-81f3-862d-f9a6d9a4c886"
  },
  {
    "updated": "2025-05-05T15:41:00.000+00:00",
    "Quadrant": "平台",
    "Description": "在使用 数据产品思维 构建产品时，数据血缘、数据可发现性、数据治理非常重要。我们的团队发现 DataHub 在这些方面能提供非常有效的支持。DataHub 的早期版本在需要更新元数据模型时，要求用户手动复制管理来 自主产品的同步。近期的更新引入了通过插件实现的元数据模型定制。DataHub 的另一个有用功能是从源头到 处理再到消费的强大端到端数据脉络。DataHub 既支持基于推送的集成，也支持基于拉动的数据血缘提取，可 自动抓取跨数据源、调度器、协调器（通过扫描 Airflow DAG）、处理管道任务和仪表板等元数据。作为完整数 据目录的一个开源选项，DataHub 逐渐成为我们团队的默认选择。\n\n[数据产品思维 \\| Technology Radar \\| Thoughtworks China](https://www.thoughtworks.com/cn/radar/techniques/data-product-thinking-for-fair-data)\n[DataHub: #1 Open Source Metadata Platform for AI & Data](https://datahubproject.io/)\n[A Custom Metadata Model \\| DataHub](https://datahubproject.io/docs/metadata-models-custom/)\n",
    "Tags": [],
    "ID": "48",
    "LastChange": "51",
    "Aliases": "",
    "Ring": "assess",
    "Name": "DataHub",
    "notion_page_id": "1eb0aea5-43e6-8185-a517-fd715708028b"
  },
  {
    "updated": "2025-05-06T00:15:00.000+00:00",
    "Quadrant": "平台",
    "Description": "## 一、什么是 Docker？\n\nDocker 是一个开源的**容器化平台**，用于打包、分发和运行应用程序。它通过将应用与其依赖环境打包到容器中，实现跨平台一致性部署。\n\n---\n\n## 二、核心概念\n\n| 概念         | 说明                                                             |\n|--------------|------------------------------------------------------------------|\n| 镜像（Image）| 应用及其环境的只读模板，类似系统快照                           |\n| 容器（Container）| 镜像运行时的实例，轻量、隔离、可移植                              |\n| Dockerfile   | 构建镜像的配置文件，定义安装步骤和环境                          |\n| Docker Hub   | 官方的镜像仓库，支持上传/下载公共或私有镜像                     |\n| Volume       | 容器与宿主机之间的数据持久化机制                                |\n| Network      | 管理容器之间的网络连接（bridge、host、overlay 等）             |\n\n---\n\n## 三、核心优势\n\n- 🧱 **一致性部署**：开发、测试、生产环境保持一致  \n- ⚡ **启动快速**：比虚拟机轻量，秒级启动  \n- 🚀 **资源隔离**：每个容器互不干扰，可单独管理  \n- 🔁 **易于集成 CI/CD**：自动化测试、构建、部署流程  \n- 🌐 **跨平台运行**：只要支持 Docker 的平台即可运行\n",
    "Tags": [],
    "ID": "47",
    "LastChange": "52",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Docker",
    "notion_page_id": "1eb0aea5-43e6-8175-98a9-f9925071c526"
  },
  {
    "updated": "2025-05-05T13:17:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Dify 是一个 UI 驱动的用于开发大语言模型应用程序的平台，它使原型设计更加容易访问。它支持用户使用提示 词模板开发聊天和文本生成应用。此外，Dify 支持使用导入数据集的检索增强生成（RAG），并且能够与多个模 型协同工作。我们对这类应用很感兴趣。不过，从我们的使用经验来看，Dify 还没有完全准备好投入大范围使 用，因为某些功能目前仍然存在缺陷或并不成熟。但目前，我们还没有发现更好的竞品\n[GitHub - langgenius/dify: Dify is an open-source LLM app development platform. Dify's intuitive interface combines AI workflow, RAG pipeline, agent capabilities, model management, observability features and more, letting you quickly...](https://github.com/langgenius/dify)",
    "Tags": [],
    "ID": "46",
    "LastChange": "50",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Dify",
    "notion_page_id": "1ea0aea5-43e6-817f-b16a-f81b72c64ad7"
  },
  {
    "updated": "2025-05-05T12:51:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "The [Vercel AI](https://ai-sdk.dev/) SDK is the TypeScript toolkit designed to help developers build AI-powered applications with React, Next.js, Vue, Svelte, Node.js, and more.",
    "Tags": [],
    "ID": "45",
    "LastChange": "49",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Vercel AI SDK",
    "notion_page_id": "1ea0aea5-43e6-814b-a218-e106154e8f1b"
  },
  {
    "updated": "2025-05-05T12:30:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[**CrewAI**](https://github.com/crewAIInc/crewAI) 是一个专为构建和管理 AI 代理而设计的平台，它能让多个 AI 代理协同工作，共同完成复杂任务。我们可以将其理解为一群 AI 工作者组成的团队，每个成员都有自己的专长，并能齐心协力以达成共同目标。我们曾经在雷达中的[LLM 驱动自主代理](https://www.thoughtworks.com/zh-cn/radar/techniques/llm-powered-autonomous-agents)中提及过它。除了现有的 Python 开源库以外，CrewAI 现在还推出了企业级的解决方案，使组织可以创建基于代理的应用程序并应用于真实业务场景，在云基础设施上运行，并连接到现有的数据源（如 SharePoint 或者 JIRA）。我们已经多次使用 CrewAI 去应对生产环境中出现的问题，例如自动验证促销码，调查交易失败的原因以及处理客户支持相关的请求。在代理技术快速发展的背景下，我们对 CrewAI 的能力充满信心，因此将其归入“评估”类别。",
    "Tags": [],
    "ID": "44",
    "LastChange": "48",
    "Aliases": "",
    "Ring": "assess",
    "Name": "CrewAI",
    "notion_page_id": "1ea0aea5-43e6-8119-ba62-cf161029c5bc"
  },
  {
    "updated": "2025-05-05T12:23:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[Heroku](https://www.thoughtworks.com/zh-cn/radar/platforms/heroku) 曾是许多开发者快速发布和部署应用程序的优秀选择。近年来，我们也看到了像 [Vercel](https://www.thoughtworks.com/zh-cn/radar/platforms/vercel) 这样更现代、轻量且易用的平台的兴起，虽然它们主要面向前端应用的部署。而在全栈部署领域的一个替代选择是 [**Railway**](https://railway.com/)，这是一个云端 PaaS 平台，简化了从 GitHub/Docker 部署到生产环境可观测性的整个流程。\n\nRailway 支持大多数主流编程框架、数据库以及容器化部署。作为应用程序的长期托管平台，您可能需要仔细比较不同平台的成本。目前，我们的团队对 Railway 的部署和可观测性体验良好。其操作流畅，并且能够很好地与我们倡导的 [持续部署](https://www.thoughtworks.com/zh-cn/radar/techniques/continuous-deployment) 实践相结合。",
    "Tags": [],
    "ID": "43",
    "LastChange": "47",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Railway",
    "notion_page_id": "1ea0aea5-43e6-812f-b4e8-f5920afa64b1"
  },
  {
    "updated": "2025-05-05T12:20:00.000+00:00",
    "Quadrant": "平台",
    "Description": "类似于 [Langfuse](https://www.thoughtworks.com/zh-cn/radar/platforms/langfuse)、[Weights & Biases](https://www.thoughtworks.com/zh-cn/radar/platforms/weights-biases)和 [Arize Phoenix](https://www.thoughtworks.com/zh-cn/radar/platforms/arize-phoenix)，[**Helicone**](https://www.helicone.ai/) 是一个面向企业需求的托管 LLMOps 平台，专注于管理 LLM 成本、评估 ROI 和降低风险。作为一个开源且以开发者为中心的平台，Helicone 支持生产级 AI 应用，覆盖整个 LLM 生命周期的提示词实验、监控、调试和优化。它能够实时分析来自不同 LLM 提供商的成本、利用率、性能以及代理堆栈跟踪。虽然 Helicone 大大简化了 LLM 运维管理，但作为一个正在发展的平台，它可能需要一定的专业知识才能充分利用其先进功能。我们的团队目前正在使用该平台，并获得了良好的体验。",
    "Tags": [],
    "ID": "42",
    "LastChange": "46",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Helicone",
    "notion_page_id": "1ea0aea5-43e6-8174-99a6-cbce9ca9b0ea"
  },
  {
    "updated": "2025-05-05T12:02:00.000+00:00",
    "Quadrant": "工具",
    "Description": "尽管我们仍然推荐使用 最简特性开关，但随着团队的扩展和开发速度的加快，管理手工制作的开关变得更加 复杂。现在我们团队广泛使用 Unleash，它能够应对这种复杂性并支持 CI/CD。它既可以作为服务使用，也可 以自托管。Unleash 提供了多个语言的 SDK，拥有良好的开发者体验和友好的管理界面。尽管目前还没有对 OpenFeature 规范 的官方支持，但你可以找到由社区维护的 Go 和 Java providers。Unleash 既可以用于简 单特性开关，也支持分组和渐进式发布，使其成为适合大规模功能管理的选择。\n[Unleash: Open-Source Feature Management for Enterprises](https://www.getunleash.io/)\n[OpenFeature](https://openfeature.dev/)\n",
    "Tags": [],
    "ID": "41",
    "LastChange": "44",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Unleash",
    "notion_page_id": "1ea0aea5-43e6-8100-a6f5-d9c98a80daca"
  },
  {
    "updated": "2025-05-06T00:53:00.000+00:00",
    "Quadrant": "平台",
    "Description": "第一次尝试的感受：值得尝试，但是上手有点难度\n\nPros:\n- 产品级别的提示词管理\n- 可以平时积累数据集，对提示词的 Benchmark\n\nCons:\n- 对 TypeScript 生态支持有点一般\n- LLM Provider 支持有限，DeepSeek 都要自己维护，还要配置好 Tokenizer 才能正常计费\n- 操作有些繁琐，比如把记录添加到 Dataset 的操作\n- Prompt Experiments 折腾了 20 分钟，没跑通",
    "Tags": [
      "AI"
    ],
    "ID": "40",
    "LastChange": "53",
    "Aliases": "",
    "Ring": "trial",
    "Name": "Langfuse",
    "notion_page_id": "1ea0aea5-43e6-81da-b29e-eca0c5f2ac88"
  },
  {
    "updated": "2025-05-05T11:20:00.000+00:00",
    "Quadrant": "技术",
    "Description": "可以理解为**把原本在物理空间中使用的“团队墙”（Team Wall）虚拟化、数字化**，以适应远程协作的需求。\n\n ## ✅ 背景：团队墙的作用\n- **实体团队墙**在过去是常见的敏捷工具，如贴满便利贴的白板，显示：\n  - 用户故事（Story Cards）\n  - 任务状态（To Do / In Progress / Done）\n  - 阻碍、优先级、进度等\n- 它的价值是：**充当“信息辐射器”和“信息枢纽”**，让团队成员一眼就能掌握当前项目状态。\n\n## ⚠️ 问题：远程后信息分散\n- 随着远程办公普及，实体墙不复存在。\n- 信息散落在 Jira、Trello、Notion、Slack、邮件等不同系统中，**“一目了然”变得困难**。\n- 没有集成视图会增加沟通成本、降低协作效率。\n\n## 💡 建议：构建“统一远程团队墙”\n- 用**虚拟/数字方式重建团队墙**，比如使用一个集成仪表板，将各系统数据聚合展示。\n- 它**不是数据存储系统**，而是**统一视图的呈现层**。\n- 即便维护这面墙需要成本，比如手动同步状态，**也值得做**，因为它能恢复团队对齐感和透明度。\n\n## 🔁 仪式感：延续更新行为\n- 线下团队可能通过每日 Standup 更新实体墙。\n- 同样地，数字团队墙也可嵌入到每日会议、例会、迭代评审等“团队仪式”中。\n\n### 总结一句话：\n**“统一远程团队墙”是为了解决远程协作中信息分散的问题，通过构建一个集成视图平台，让团队像以前看实体墙一样，快速掌握任务与进度的全貌。**\n",
    "Tags": [],
    "ID": "39",
    "LastChange": "41",
    "Aliases": "",
    "Ring": "assess",
    "Name": "统一远程团队墙",
    "notion_page_id": "1ea0aea5-43e6-81bb-97a5-c23122291cf7"
  },
  {
    "updated": "2025-05-05T10:33:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "我们将 [**React Hook Form**](https://react-hook-form.com/) 视为 Formik 的替代方案。由于默认使用非受控组件，它提供了显著更好的开箱即用的表现，特别是在大型表单上。React Hook Form 很好地和各种基于 schema 的验证库（比如[Yup](https://github.com/jquense/yup), [Zod](https://github.com/colinhacks/zod) 等）进行了集成。此外 React Hook Form 提供了很大的灵活性，使其易于和现有代码库和其他库集成。你可以把 React Hook Form 和像[shadcn](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/shadcn)或者[AntD](https://ant.design/)这样的外部受控组件库一起使用。凭借出色的性能、无缝集成和活跃的开发社区，它是构建大型表单或表单密集型应用的可靠选择。",
    "Tags": [],
    "ID": "37",
    "LastChange": "40",
    "Aliases": "",
    "Ring": "assess",
    "Name": "React Hook Form",
    "notion_page_id": "1ea0aea5-43e6-8195-9f52-e2b3b2695fbd"
  },
  {
    "updated": "2025-05-05T10:32:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "[**GoFr**](https://github.com/gofr-dev/gofr) 是一个专为构建 [Golang](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/go-language) 微服务而设计的框架，通过抽象常见的微服务功能（如日志记录、追踪、指标、配置管理和 Swagger API 文档生成）来简化开发工作。它支持多种数据库，处理数据库迁移，并且能够与 Kafka 和 NATs 等消息代理进行 pub/sub 操作。此外，GoFr 还包括支持定时任务的 cron 作业功能。该框架旨在降低构建和维护微服务的复杂性，让开发者能够将更多精力集中于业务逻辑的编写，而非基础设施的管理。尽管市面上已有许多流行的 Go 库用于构建 Web API，但 GoFr 正在逐步获得关注，非常值得基于 Golang 的微服务开发团队探索和使用。",
    "Tags": [],
    "ID": "36",
    "LastChange": "39",
    "Aliases": "",
    "Ring": "assess",
    "Name": "GoFr",
    "notion_page_id": "1ea0aea5-43e6-8189-be04-c3d3bcfe5b33"
  },
  {
    "updated": "2025-05-05T12:11:00.000+00:00",
    "Quadrant": "工具",
    "Description": "目前就是用作展示组件使用，感觉比做一个测试页面来的方便，而且能起到一定的文档作用。",
    "Tags": [
      "前端",
      "交付效能"
    ],
    "ID": "35",
    "LastChange": "45",
    "Aliases": "",
    "Ring": "trial",
    "Name": "Ladle",
    "notion_page_id": "1ea0aea5-43e6-8174-9216-f801870bcb3b"
  },
  {
    "updated": "2025-05-05T09:08:00.000+00:00",
    "Quadrant": "平台",
    "Description": "https://firebase.studio/\n\nFirebase Studio accelerates your entire development lifecycle with AI agents. Build backends, front ends, and mobile apps, all in one place.",
    "Tags": [],
    "ID": "34",
    "LastChange": "37",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Firebase Studio",
    "notion_page_id": "1ea0aea5-43e6-81d0-abc2-f3078ca0a1b0"
  },
  {
    "updated": "2025-05-05T09:07:00.000+00:00",
    "Quadrant": "平台",
    "Description": "谷歌的**[Firebase](https://firebase.google.com/)**自2016年被我们纳入[无服务器架构](https://www.thoughtworks.com/zh-cn/radar/techniques/serverless-architecture)以来，发生了重大的演变。 Firebase 是一个综合性平台，可用于构建移动和Web应用，并运行在谷歌可伸缩基础设施上。我们尤其喜欢 Firebase App Distribution 和 Firebase Remote Config。前者可通过持续部署流水线，轻松发布应用程序的测试版本。而后者可以将配置更改，动态地推送给应用程序，而无须重新发布应用程序。",
    "Tags": [],
    "ID": "33",
    "LastChange": "36",
    "Aliases": "",
    "Ring": "assess",
    "Name": "FireBase",
    "notion_page_id": "1ea0aea5-43e6-810b-a48d-c80cc6ba4c71"
  },
  {
    "updated": "2025-05-05T09:05:00.000+00:00",
    "Quadrant": "技术",
    "Description": "尽管 **基础设施即代码** 是一种相对旧的技术（我们早在2011年的技术雷达中就已经介绍过它），但在现代云时代，构建基础设施的行为已经成为了将配置指令传递到云平台的重要组成部分，因此它变得非常重要。当我们说“即代码”时，是指我们在软件领域学到的所有良好实践都应应用于基础设施。使用源代码控制，遵守 [DRY原则](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)、模块化、可维护性以及使用自动化测试和部署都是关键的实践。我们当中具有深厚软件和基础设施背景的人，需要体谅和支持那些没有做过这些的同事。仅仅说“像对待代码一样处理基础设施”还不够，我们需要确保从软件世界学到的来之不易的经验教训，也能够同样应用到整个基础设施领域。",
    "Tags": [],
    "ID": "32",
    "LastChange": "35",
    "Aliases": "",
    "Ring": "assess",
    "Name": "基础设施即代码",
    "notion_page_id": "1ea0aea5-43e6-81fb-bbff-c8f262bd3f92"
  },
  {
    "updated": "2025-05-05T09:04:00.000+00:00",
    "Quadrant": "技术",
    "Description": "[DORA \\| DORA’s software delivery metrics: the four keys](https://dora.dev/guides/dora-metrics-four-keys/)\n为了度量软件交付的效能，越来越多的组织开始采用由 DORA 研究项目定义的交付核心四指标，即：更改前置 时间、部署频率、平均修复时间（MTTR）和变更失败率。这项研究及其统计分析展示了高效能交付团队和这些 指标的高度相关性，它们为衡量一个团队、甚至整个交付组织的表现提供了极佳的领先指标。\n\n虽然我们仍是这些指标的支持者，但自从我们最早开始监控它们以来，也得到了一些教训。我们也持续看到被误 导的度量方式，这些方式使用的工具仅基于持续交付（CD）流水线。在衡量稳定性指标（MTTR 和更改失败百分 比）时，仅依赖 CD 流水线数据提供的信息并不足以确定部署失败对真实用户的影响。只有包含真实事故（如用 户服务降级）的数据时，稳定性指标才有意义。\n\n与其它所有指标一样，我们建议始终牢记度量这些指标的终极目的，并使用它们反复思考和学习。例如，在花费 数周时间构建复杂仪表板工具之前，可以考虑定期在团队回顾会议当中进行[DORA 快速检查](https://dora.dev/quickcheck/)。这样的做法能够 使团队有机会思考哪些[能力](https://dora.dev/capabilities/)应被提升以改进这些指标，这比过于详细的开箱即用工具更有效。\n[DORA \\| Research](https://dora.dev/research/)",
    "Tags": [],
    "ID": "31",
    "LastChange": "34",
    "Aliases": "",
    "Ring": "assess",
    "Name": "交付核心四指标",
    "notion_page_id": "1ea0aea5-43e6-81e2-a0b8-d17676a822d9"
  },
  {
    "updated": "2025-05-05T09:03:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[**Grafana Loki**](https://grafana.com/docs/loki/)是一个受 Prometheus 启发的横向可扩展，高可用的多租户日志聚合系统。Loki 只对日志的元数据进行索引，并把它当做日志流的标签集，而日志数据本身则储存在像 S3, GCS 或 Azure Blob Storage 这样的块存储方案中。这样做的好处是 Loki 比竞争对手的运维复杂度更低，同时也降低了存储成本。正如你所期待的那样，它与 Grafana 和[Grafana Alloy](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/grafana-alloy)深度集成，即使其他的日志采集机制也被支持。\n\nLoki 3.0 引入了对原生[OpenTelemetry](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/opentelemetry)的支持，这使得与 OpenTelemetry 系统的数据摄入与集成如配置一个端点一样简单。此外，它还提供了高级的多租户功能，例如通过 shuffle-sharding 的方式实现各租户间的隔离，避免异常的租户(比如正在执行高负载查询或者出现故障)影响到集群中的其他租户。如果你还没有关注 Grafana 生态系统的最新发展，现在正是个好时机——它正在快速地演进。",
    "Tags": [],
    "ID": "30",
    "LastChange": "33",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Grafana Loki",
    "notion_page_id": "1ea0aea5-43e6-8113-9908-ff561da18d3e"
  },
  {
    "updated": "2025-05-05T09:02:00.000+00:00",
    "Quadrant": "工具",
    "Description": "前身为 Grafana Agent，[**Grafana Alloy**](https://grafana.com/docs/alloy/latest/) 是一个开源的 [OpenTelemetry](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/opentelemetry) Collector。Alloy 被设计为一个一体化的遥测数据收集器，用于收集包括日志、指标和跟踪在内的所有遥测数据。它支持常用的遥测数据格式，如 OpenTelemetry、[Prometheus](https://www.thoughtworks.com/zh-cn/radar/tools/prometheus) 和 Datadog。随着 [Promtail 最近被弃用](https://grafana.com/docs/loki/latest/send-data/promtail/)，Alloy 正逐渐成为遥测数据收集的首选工具——特别是在使用 Grafana 可观察性技术栈时，用于日志数据的收集。",
    "Tags": [],
    "ID": "29",
    "LastChange": "32",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Grafana Alloy",
    "notion_page_id": "1ea0aea5-43e6-81ea-86a5-cf29fe05e825"
  },
  {
    "updated": "2025-05-05T09:01:00.000+00:00",
    "Quadrant": "技术",
    "Description": "在提示生成中，最大的挑战之一是确保 AI 工具能够访问与任务相关的所有上下文信息。这些上下文信息通常已经存在于我们每天使用的系统中，如维基、问题追踪器、数据库或可观察性系统。AI 工具与这些信息源的无缝集成可以显著提高 AI 生成输出的质量。\n\n[**模型上下文协议**](https://github.com/modelcontextprotocol)（MCP）是由 Anthropic 发布的开放标准，提供了一个标准化的框架，用于将 LLM 应用与外部数据源和工具集成。它定义了 MCP 服务器和客户端，服务器访问数据源，客户端则集成并使用这些数据来增强提示。许多编码助手已经实现了 MCP 集成，使其能够作为 MCP 客户端运行。MCP 服务器可以通过两种方式运行：本地运行，作为在用户机器上运行的 Python 或 Node 进程；或者远程运行，作为通过 SSE 连接的服务器（尽管我们尚未看到远程服务器的使用）。目前，MCP 主要以第一种方式使用，开发者通过克隆开源的 [MCP](https://mcpservers.org/) [服务器](https://mcp.so/) [实现](https://smithery.ai/) 来使用它。虽然本地运行的服务器提供了一种避免第三方依赖的简洁方式，但它们对于非技术用户仍然不够友好，并且带来了治理和更新管理等挑战。尽管如此，可以预见这一标准未来可能会发展成一个更成熟、更易于用户使用的生态系统。",
    "Tags": [],
    "ID": "28",
    "LastChange": "31",
    "Aliases": "",
    "Ring": "assess",
    "Name": "MCP",
    "notion_page_id": "1ea0aea5-43e6-81a6-a39a-c44723bd02f8"
  },
  {
    "updated": "2025-05-05T09:00:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[**Supabase**](https://supabase.com/) 是一个开源的 [Firebase](https://www.thoughtworks.com/zh-cn/radar/platforms/firebase) 替代方案，用于构建可扩展且安全的后端。它提供了一整套集成服务，包括 PostgreSQL 数据库、认证、即时 API、Edge Functions、实时订阅、存储以及向量嵌入。 Supabase 的目标是简化后端开发，使开发者能够专注于构建前端体验，同时利用开源技术的强大功能和灵活性。与 Firebase 不同，Supabase 基于 PostgreSQL 构建。如果您正在进行原型设计或开发 MVP（最小可行产品），Supabase 值得考虑，因为在原型阶段之后，它更容易迁移到其他 SQL 解决方案。\n",
    "Tags": [],
    "ID": "27",
    "LastChange": "30",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Supabase",
    "notion_page_id": "1ea0aea5-43e6-813f-9b8a-c748260ed8ed"
  },
  {
    "updated": "2025-05-05T08:58:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Graph databases store information as arbitrarily interconnected nodes linked by named relations, rather than as tables and joins. Schema-less and highly extensible, they are an excellent choice for modelling semi-structured data in complex domains. Neo4j is the front-runner in the space both its REST API and its Cypher query language support simple and fast storage and traversal of graphs.",
    "Tags": [],
    "ID": "26",
    "LastChange": "29",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Neo4j",
    "notion_page_id": "1ea0aea5-43e6-812e-bd44-c40c03b52546"
  },
  {
    "updated": "2025-05-05T08:57:00.000+00:00",
    "Quadrant": "工具",
    "Description": "JavaScript的世界日新月异，随着我们使用框架的经验越来越多，我们的倾向也在改变。我们深入使用某些框架，其他备选框架自然黯然失色。在React前端测试方面，**[React Testing Library](https://testing-library.com/)**就是这样一个例子。我们团队很喜欢的是，用这个框架写的测试比其他框架(如 [Enzyme](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/enzyme))更健壮，因为它鼓励独立测试组件间的关系，而不是测试全部实现细节。 这种思维源自于[测试库](https://testing-library.com/)，React Testing Library 是它的一部分，它还为像[Angular](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/angular) 和 [Vue.js](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/vue-js)这样的框架提供了一整套库。",
    "Tags": [],
    "ID": "25",
    "LastChange": "28",
    "Aliases": "",
    "Ring": "assess",
    "Name": "React Testing Library",
    "notion_page_id": "1ea0aea5-43e6-8160-97fb-d6f75acbaf7d"
  },
  {
    "updated": "2025-05-05T08:57:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "**[React Hooks](https://reactjs.org/docs/hooks-intro.html)** 引入了一种管理状态逻辑的新方法；鉴于React组件相比较类来说更接近于函数，Hooks接受了这一点并将状态传给函数，而不是将函数作为方法传给带有状态的类。React应用中状态管理的另一个主要内容是 [Redux](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/redux) ，我们注意到它已经受到审查，可以看到，在某些时候Redux的复杂性并不值得，对于这些情况，使用Hooks的简单方法是更可取的。完全靠自己去引入这种实现很快会变得棘手；因此我们推荐考虑结合 [React Context](https://reactjs.org/docs/context.html) 以及useContext和useReducer Hooks，并根据这篇 [博客文章](https://blog.logrocket.com/guide-to-react-usereducer-hook/) 中解释的路线来实现。",
    "Tags": [],
    "ID": "24",
    "LastChange": "27",
    "Aliases": "",
    "Ring": "assess",
    "Name": "React Hooks",
    "notion_page_id": "1ea0aea5-43e6-8110-9c99-dd6a868e496a"
  },
  {
    "updated": "2025-05-05T08:56:00.000+00:00",
    "Quadrant": "工具",
    "Description": "Ruff 是一个新的 Python linter。使用 linter 是毋庸置疑的，只需要考虑具体要使用哪一个。Ruff 能够脱颖而 出有两个原因：开箱即用的体验，以及性能。其中内置了 500 多条规则，可以轻松取代 Flake8 和它的许多插件。 我们的经验证实了 Ruff 团队对其性能的说法。实际上，它的速度至少比其它 linter 快出一个数量级，这是一个 巨大的优势，有助于减少大型代码库的构建时间。基于上述原因，Ruff 已成为我们实施 Python linter 的默认 选择。\n[GitHub - astral-sh/ruff: An extremely fast Python linter and code formatter, written in Rust.](https://github.com/astral-sh/ruff)",
    "Tags": [],
    "ID": "23",
    "LastChange": "26",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Ruff",
    "notion_page_id": "1ea0aea5-43e6-81a4-ac03-f2ceabb20aae"
  },
  {
    "updated": "2025-05-05T08:55:00.000+00:00",
    "Quadrant": "工具",
    "Description": "Mermaid 通过使用类似 Markdown 的标记语言来生成图表。自从上次在技术雷达中介绍以来，Mermaid 添加 了对更多图表和与源代码存储库、集成开发环境和知识管理工具集成的支持。 值得注意的是，它在 GitHub 和 GitLab 等流行源代码存储库中得到原生支持，从而可以在 Markdown 文档中嵌入并轻松更新 Mermaid 图表。 我们的许多团队都倾向于使用 Mermaid 作为他们的图表即代码工具，因为它易于使用、集成广泛，且支持的图 表类型不断增多。\n[Mermaid \\| Diagramming and charting tool](https://mermaid.js.org/)\n[Integrations \\| Mermaid](https://mermaid.js.org/ecosystem/integrations-community.html)",
    "Tags": [],
    "ID": "22",
    "LastChange": "25",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Mermaid",
    "notion_page_id": "1ea0aea5-43e6-81c9-84a0-eec298e81873"
  },
  {
    "updated": "2025-05-05T08:54:00.000+00:00",
    "Quadrant": "工具",
    "Description": "AI 辅助编程工具的竞赛仍在继续，而其中最引人注目的一个就是 Cursor。Cursor 是一个以 AI 为核心的代码 编辑器，旨在通过深度整合 AI 到编码工作流中来提升开发者的生产力。虽然我们在之前的雷达评估中已经关注 到它，但显然，Cursor 近期的持续改进已为其带来了质的飞跃。在我们的使用中，Cursor 展现了基于现有代 码库的强大上下文推理能力。尽管其他 AI 代码工具如 GitHub Copilot 已经可以围绕代码片段进行代码生成或 协作，Cursor 的多行和多文件编辑操作让它脱颖而出。Cursor 是基于 VSCode 代码库分叉开发的，提供了一 种符合开发者直觉的快速且直观的交互方式。通过快捷键 ctrl/cmd+K 和 ctrl/cmd+L 即可完成强大的操作。 Cursor 在 AI 编程工具的竞赛中引领了新一轮的竞争，尤其是在开发者交互和代码库理解方面更为突出。\n[Cursor - The AI Code Editor](https://www.cursor.com/)",
    "Tags": [],
    "ID": "21",
    "LastChange": "24",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Cursor",
    "notion_page_id": "1ea0aea5-43e6-81ae-9182-c6de804a750b"
  },
  {
    "updated": "2025-05-05T08:53:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[ESLint](https://eslint.org/)作为JavaScript的代码检查工具，它提供了很多规则集、推荐规则和插件，可以扩展为不同的框架或JavaScript风格。通过在开发时对代码进行实时分析，Eslint可以极大地帮助团队在开发过程中建立和遵循代码规范。Eslint不仅可以通过实施最佳实践和代码规范，对编码实践进行标准化，还能识别代码中的漏洞。这是因为ESLint与大多数IDE都能很好地集成，并可以在编码过程中提供实时反馈。特别是它的样式规则可以自动修复代码错误，持续有效并且不会产生额外的开发成本。ESlint社区的文档很好地解释了它的编码模式，可以帮助开发人员快速掌握规则。随着ESLint变得越来越通用和强大，它已经被行业所认可。例如[TypeScript](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/typescript)团队就选择支持ESLint并与其合作，而非TSLint。",
    "Tags": [],
    "ID": "20",
    "LastChange": "23",
    "Aliases": "",
    "Ring": "assess",
    "Name": "ESLint",
    "notion_page_id": "1ea0aea5-43e6-812f-908a-fe7aff4bcc90"
  },
  {
    "updated": "2025-05-15T00:21:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "## 背景\nJavaScript 的局限性：\n- JS 是动态类型语言，缺乏类型约束，易出现运行时错误。\n- 项目一旦变大，难以维护、重构、协作。\n- 没有模块化、接口、访问修饰符等工程化特性。\n\nTypeScript 的诞生：\n微软为了解决上述问题，开发了 TS，目标是支持大型项目开发。\n借助类型系统和编译阶段的检查，提高开发效率和代码健壮性。\n\n| 分类       | 项目    | 描述                                              |\n| -------- | ----- | ----------------------------------------------- |\n| **语言定位** | 语言类型  | JavaScript 的超集，添加了类型系统和工程化能力                    |\n|          | 类型系统  | 支持可选的静态类型检查，提供类型推断、接口、泛型等                       |\n|          | 编译机制  | 编译型语言，需通过 `tsc` 编译为原生 JavaScript                |\n|          | 向后兼容性 | 兼容所有 JavaScript 语法，可渐进式引入                       |\n|          | 设计目标  | 面向中大型项目，提升代码可维护性、可读性和协作效率                       |\n| **核心特点** | 类型系统  | 静态类型检查、自定义类型、联合类型、类型推断、泛型支持                     |\n|          | OOP支持 | 支持类、接口、继承、访问修饰符（`public/private/protected`）等    |\n|          | 工程化能力 | 模块系统（ESM/CommonJS）、严格模式、类型配置文件（`tsconfig.json`） |\n|          | IDE支持 | 强大自动补全、类型跳转、错误提示、重构建议（VS Code 深度集成）             |\n|          | 开发生态  | 与现代主流前端/后端框架高度集成（如 Angular/Nest/Vue3/React 等）   |\n",
    "Tags": [],
    "ID": "19",
    "LastChange": "67",
    "Aliases": "",
    "Ring": "trial",
    "Name": "TypeScript",
    "notion_page_id": "1ea0aea5-43e6-8103-8878-ff596a7db99e"
  },
  {
    "updated": "2025-05-05T08:51:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[**v0**](https://v0.dev/) 是由 Vercel 开发的一款 AI 工具，可根据截图、Figma 设计或简单的提示生成前端代码。它支持包括 [React](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/react-js)、[Vue](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/vue-js)、[shadcn](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/shadcn) 和 [Tailwind](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/tailwind-css) 在内的多种前端框架。除了 AI 生成代码的功能之外，v0 还提供了出色的用户体验，包括预览生成的代码并一步部署到 Vercel 的能力。尽管构建真实世界的应用程序通常需要集成多个功能，不仅仅局限于单个界面，但 v0 为原型设计提供了一个稳固的工具，并可作为开发复杂应用程序的起点初始化代码。",
    "Tags": [],
    "ID": "18",
    "LastChange": "21",
    "Aliases": "",
    "Ring": "assess",
    "Name": "v0",
    "notion_page_id": "1ea0aea5-43e6-8162-a493-ed8680df725c"
  },
  {
    "updated": "2025-05-05T08:31:00.000+00:00",
    "Quadrant": "工具",
    "Description": "不论是对设计师，还是多角色团队而言，**[Figma](https://www.figma.com/)** 都已被证明是协作设计的首选工具。它允许开发人员和其他角色通过浏览器查看和评论设计，而无需使用桌面版本。和它的竞争对手（如Invision 或 Sketch）相比，Figma 将版本控制、协作设计和设计分享这些功能都集中到一个工具上，这使得我们的团队更容易一起想出新点子。除了实时设计和协作功能外，Figma 还提供了一个 API 以帮助改善 [DesignOps](https://www.thoughtworks.com/zh-cn/radar/techniques/designops) 流程 。",
    "Tags": [],
    "ID": "17",
    "LastChange": "20",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Figma",
    "notion_page_id": "1ea0aea5-43e6-81d2-866f-d149a817d877"
  },
  {
    "updated": "2025-05-15T07:33:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Pros:\n- 95% 的工作是专注的业务上\nCons:\n- 还不太熟悉，安装依赖，查 Log 都不熟悉\n\n整体感受：值得继续尝试\n\n今天使用 CloudFlare Worker + Email Routing 实现了无限邮箱+Github 验证码解析并转发到飞书群的功能\n\n[这里](https://github.com/cloudflare/dmarc-email-worker) 有个更复杂的例子。\n\n- [Worker Examples](https://developers.cloudflare.com/workers/examples/?languages=JavaScript)",
    "Tags": [
      "架构模式"
    ],
    "ID": "16",
    "LastChange": "67",
    "Aliases": "",
    "Ring": "trial",
    "Name": "边缘函数",
    "notion_page_id": "1ea0aea5-43e6-8196-9b2d-c8cf15d32a89"
  },
  {
    "updated": "2025-05-05T05:13:00.000+00:00",
    "Quadrant": "技术",
    "Description": "我们遗憾地发现，人们很少使用[特性开关](https://martinfowler.com/articles/feature-toggles.html)，且经常混淆其类型和使用场景。为了从[持续集成](https://martinfowler.com/articles/continuousIntegration.html)中受益，一些团队会使用 [LaunchDarkly](https://launchdarkly.com/) 等重量级平台来实现特性切换（包括发布切换），即使他们所需要的仅仅是简单地 if/else 条件控制。 因此，除非你需要 A/B 测试、[金丝雀发布](https://martinfowler.com/bliki/CanaryRelease.html)或将特性发布的职责交给业务人员，我们建议使用 **最简特性开关** 来代替不必要的复杂的特性切换框架。",
    "Tags": [],
    "ID": "15",
    "LastChange": "18",
    "Aliases": "",
    "Ring": "assess",
    "Name": "最简特性开关",
    "notion_page_id": "1ea0aea5-43e6-81c4-8963-fb5339537771"
  },
  {
    "updated": "2025-05-05T04:33:00.000+00:00",
    "Quadrant": "技术",
    "Description": "引入[微服务](https://martinfowler.com/articles/microservices.html)令我们受益匪浅，使用微服务，团队可以扩展那些独立部署及维护的服务的交付。遗憾的是，我们也看到许多团队创建了单体前端——一个建立在后端服务之上的大而混乱的浏览器应用程序——这在很大程度上抵消了微服务带来的好处。自从问世以来， **微前端** 持续变得流行。我们已经看到，许多团队采用这种架构的某种形式，来管理多开发人员和多团队的复杂性，以提供相同的用户体验。在去年的六月份，这个技术的发起人之一，发表了一篇[介绍性的文章](https://martinfowler.com/articles/micro-frontends.html)，可以起到微前端参考文献的作用。它展示了这种设计是如何通过各种Web编程机制实现的，以及使用[React.js](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/react-js)构建了一个示例应用程序。我们有理由相信，随着大型组织尝试在跨多团队中分解UI开发，这种风格将越来越流行。\n\n-- Via Thought Works",
    "Tags": [],
    "ID": "14",
    "LastChange": "17",
    "Aliases": "",
    "Ring": "assess",
    "Name": "微前端",
    "notion_page_id": "1ea0aea5-43e6-8113-aef1-eb8d2e14df22"
  },
  {
    "updated": "2025-05-05T04:32:00.000+00:00",
    "Quadrant": "技术",
    "Description": "在迭代速度快、用户需求不断演进的产品开发环境中，设计是一个不断变化的领域。这意味着对设计决策输入需求会一直持续下去。借鉴了用 ADR（架构决策记录）记录软件架构决策的思路，采用类似的格式，以设计系统决策记录来记录设计系统决策以及相应的依据、研究洞见和实验结果，这有效地传达了设计系统决策似乎已成为产品开发团队新的需求。这种轻量级的方式也被 zeroheight 推荐。这一方法可以减少新人上手时间，推动讨论的进行。\n[Capturing your design system decisions](https://zeroheight.com/blog/capturing-your-design-system-decisions/)",
    "Tags": [],
    "ID": "13",
    "LastChange": "16",
    "Aliases": "",
    "Ring": "assess",
    "Name": "设计系统决策记录",
    "notion_page_id": "1ea0aea5-43e6-8144-94ad-f091c4a40a5a"
  },
  {
    "updated": "2025-05-05T04:30:00.000+00:00",
    "Quadrant": "技术",
    "Description": "随着应用开发变得越来越动态和复杂，交付风格一致且好用的产品成为了一项挑战，尤其是在有多个团队参与 不同产品开发的大型组织中。设计系统定义了一系列的设计模式、组件库以及良好的设计和工程实践，以确保 数字产品的一致性。设计系统从过去的企业风格指南演变而来，提供易于查找和使用的共享组件库和文档。通常，设计系统的风格指南以代码的形式记录并进行版本控制，比简单的文档记录更加清晰且易于维护。设计系统已经成为跨团队和学科进行产品开发时的标准方法，每当需要新的视觉组件时，团队不用重新发明轮子，因此能够集中精力，专注解决产品本身的种种挑战。\n\n我们的经验表明，团队在构建设计系统时很少采用产品为中心的思维方式。共享组件库和文档的主要消费者是产品开发团队。在使用产品为中心的思维方式时，设计系统所有者应该与消费者（开发团队）合作，建立共情。 我们发现，许多组件库之所以受到批评，是因为所有者团队无法快速响应消费者的需求，并且无法接受来自外 部的贡献。产品为中心的思维方式还要求组织思考是否应该允许和怎样向设计系统做出贡献，以及如何管理这 些贡献——在这个话题上，我们推荐采用设计系统决策记录。对我们来说，维护一个良好的设计系统或组件库 不光是技术工作，也同样是社交工作\n\n[设计系统决策记录 \\| Technology Radar \\| Thoughtworks China](https://www.thoughtworks.com/zh-cn/radar/techniques/design-system-decision-records)",
    "Tags": [],
    "ID": "12",
    "LastChange": "15",
    "Aliases": "",
    "Ring": "assess",
    "Name": "设计系统",
    "notion_page_id": "1ea0aea5-43e6-8115-b1fa-e90bc7a982dd"
  },
  {
    "updated": "2025-05-05T03:45:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "https://mdxjs.com/\nMDX lets you use JSX in your markdown content. You can import components, such as interactive charts or alerts, and embed them within your content. This makes writing long-form content with components a blast.",
    "Tags": [],
    "ID": "11",
    "LastChange": "14",
    "Aliases": "",
    "Ring": "assess",
    "Name": "MDX",
    "notion_page_id": "1ea0aea5-43e6-8153-aabd-d623ba290044"
  },
  {
    "updated": "2025-05-05T03:36:00.000+00:00",
    "Quadrant": "技术",
    "Description": "**Fuzz 测试** ，或称模糊测试，是一种已经存在很长时间但仍然较少被广泛了解的测试技术。其目标是向软件系统输入各种无效数据并观察其行为。例如，对于一个 HTTP 端点，错误的请求通常应返回 4_xx_ 错误，但 fuzz 测试往往会引发 5_xx_ 错误甚至更严重的问题。随着工具的完善以及文档支持的增强，fuzz 测试在如今显得尤为重要，尤其是在更多 AI 生成代码和[自满于 AI 生成的代码](https://www.thoughtworks.com/zh-cn/radar/techniques/complacency-with-ai-generated-code)的背景下。因此，现在是采用 fuzz 测试的好时机，以确保代码的健壮性和安全性。",
    "Tags": [],
    "ID": "10",
    "LastChange": "12",
    "Aliases": "",
    "Ring": "assess",
    "Name": "模糊测试",
    "notion_page_id": "1ea0aea5-43e6-8120-9264-cf587e82c414"
  },
  {
    "updated": "2025-05-05T02:39:00.000+00:00",
    "Quadrant": "平台",
    "Description": "大多数用于构建购物网站的电子商务解决方案通常会陷入 80/20 陷阱，即我们可以轻松构建 出 80% 的需求，但对于剩下的 20% 却无能为力。Medusa 提供了一个良好的平衡。它是一个高度可定制的 开源商业平台，允许开发人员创建独特且量身定制的购物体验，可以自我托管或运行在 Medusa 的平台上。 Medusa 基于 Next.js 和 PostgreSQL 构建，通过提供从基本购物车和订单管理到高级功能（如礼品卡模块和 不同地区的税收计算）的全面模块，加快了开发过程。\n[World's most flexible commerce platform](https://medusajs.com/)",
    "Tags": [],
    "ID": "9",
    "LastChange": "10",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Medusa",
    "notion_page_id": "1ea0aea5-43e6-814e-8845-d94442f3617a"
  },
  {
    "updated": "2025-05-05T01:53:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "Lenis 是一个为现代浏览器设计的轻量且强大的平滑滚动库。 它能够实现流畅的滚动体验，例如 WebGL 滚动同步和视差效果，这使其非常适合那些需要构建流畅、无缝滚动交互页面的团队。它提供了一种精简高效的方式来创建平滑滚动效果。然而，该库在无障碍性方面可能存在一些问题，特别是在处理垂直和水平滚动交互时，可能会让残障用户感到困惑。虽然它在视觉上很吸引人，但在实现时仍然需要仔细考虑无障碍性\n[Lenis – Get smooth or die trying](https://lenis.darkroom.engineering/)\n",
    "Tags": [],
    "ID": "8",
    "LastChange": "9",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Lenis",
    "notion_page_id": "1ea0aea5-43e6-81c4-ac93-ca503b356cc2"
  },
  {
    "updated": "2025-05-05T01:16:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "shadcn 通过提供可重用的、可直接复制粘贴的组件，挑战了传统组件库的概念。这种方法让团队拥有完整的控制权和所有权，更加容易进行定制和扩展，而这是更受欢迎的传统库如 MUI 和 Chakra UI 往往不足的地方。 shadcn 使用 Radix UI 和 Tailwind CSS 构建，能够无缝集成到任何基于 React 的应用程序中，非常适合优先 考虑控制和可扩展性的项目。它还提供一个 CLI，帮助将组件复制并粘贴到项目中。其优点还包括减少隐藏依 赖关系，避免紧耦合的实现，因此对于寻求更加自主且可适应的前端开发方法的团队来说，shadcn 正在成为一 个引人注目的替代方案。\n\n[Build your component library - shadcn/ui](https://ui.shadcn.com/)",
    "Tags": [],
    "ID": "7",
    "LastChange": "8",
    "Aliases": "",
    "Ring": "assess",
    "Name": "shadcn",
    "notion_page_id": "1ea0aea5-43e6-814e-b1ec-f66b8886cb21"
  },
  {
    "updated": "2025-05-05",
    "Quadrant": "平台",
    "Description": "Kubernetes 是一个开源容器编排平台，用于自动部署、扩展和管理容器化应用，支持高可用与弹性伸缩。",
    "Tags": [],
    "ID": "6",
    "LastChange": "7",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Kubernetes",
    "notion_page_id": "1ea0aea5-43e6-8114-8983-d37eca7162db"
  },
  {
    "updated": "2025-05-05T11:23:00.000+00:00",
    "Quadrant": "技术",
    "Description": "“1%金丝雀”是一种精细化的金丝雀发布策略（Canary Release Strategy），本质上是将新版本或新功能仅推送给一个极小比例的用户（如1%），作为一种风险最小化的试验手段。\n\n“1%金丝雀”是金丝雀发布的极小规模变种，通常指：\n- 仅向1%的真实用户发布新功能\n- 用户群体按**不同维度代表性（国家、设备、活跃度、使用场景等）**进行精心抽样\n- 作为真实环境中的探测器，验证功能在有限曝光下的可用性与风险\n\n实践需要的配置：\n| 项目             | 建议做法                           |\n|------------------|------------------------------------|\n| 目标用户选择     | 精选样本（按地域、终端、版本等）     |\n| 可观察性工具     | 接入 APM（如Datadog、Prometheus） |\n| 自动回滚机制     | 错误率超阈值即停止发布              |\n| 变更监控指标     | 崩溃率、延迟、核心路径点击变化等     |\n| 用户反馈渠道     | 引导反馈、埋点、客服协同等           |\n",
    "Tags": [
      "交付效能",
      "测试与质量"
    ],
    "ID": "5",
    "LastChange": "42",
    "Aliases": "",
    "Ring": "assess",
    "Name": "1%金丝雀",
    "notion_page_id": "1e90aea5-43e6-819a-91ad-fccb7068935d"
  },
  {
    "updated": "2025-05-04",
    "Quadrant": "语言与框架",
    "Description": "D3 是一个基于数据驱动文档的 JavaScript 库，用于构建动态、交互式的数据可视化图表，支持高度定制与 DOM 操作。",
    "Tags": [],
    "ID": "4",
    "LastChange": "4",
    "Aliases": "",
    "Ring": "assess",
    "Name": "D3",
    "notion_page_id": "1e90aea5-43e6-813d-87e3-f9e8408a9300"
  },
  {
    "updated": "2025-05-05T03:39:00.000+00:00",
    "Quadrant": "工具",
    "Description": "- [**D2**](https://github.com/terrastruct/d2) 是一个开源的[图表即代码](https://www.thoughtworks.com/zh-cn/radar/techniques/diagrams-as-code)工具，帮助用户通过文本创建和定制图表。它引入了 [D2 图表脚本语言](https://d2lang.com/tour/intro)，以简单的声明式语法优先保证可读性而非紧凑性。\n- [Icon for D2](https://icons.terrastruct.com/)\n\n",
    "Tags": [],
    "ID": "3",
    "LastChange": "13",
    "Aliases": "",
    "Ring": "assess",
    "Name": "D2",
    "notion_page_id": "1e90aea5-43e6-8157-895a-e1efda176091"
  },
  {
    "updated": "2025-05-05T03:23:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "React普及率非常高,不少AI编程平台都默认使用React(v0, Firebase Studio)",
    "Tags": [],
    "ID": "2",
    "LastChange": "11",
    "Aliases": "",
    "Ring": "trial",
    "Name": "React",
    "notion_page_id": "1e90aea5-43e6-8195-93c6-fe677be34fac"
  },
  {
    "updated": "2025-05-05",
    "Quadrant": "技术",
    "Description": "技术雷达是一种技术管理工具，用于跟踪、评估和可视化团队采用新技术的状态与演进过程。",
    "Tags": [],
    "ID": "1",
    "LastChange": "6",
    "Aliases": "",
    "Ring": "trial",
    "Name": "技术雷达",
    "notion_page_id": "1e90aea5-43e6-802f-bfed-c07d521107d9"
  }
]