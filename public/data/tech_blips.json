[
  {
    "updated": "2025-05-05T13:17:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Dify 是一个 UI 驱动的用于开发大语言模型应用程序的平台，它使原型设计更加容易访问。它支持用户使用提示 词模板开发聊天和文本生成应用。此外，Dify 支持使用导入数据集的检索增强生成（RAG），并且能够与多个模 型协同工作。我们对这类应用很感兴趣。不过，从我们的使用经验来看，Dify 还没有完全准备好投入大范围使 用，因为某些功能目前仍然存在缺陷或并不成熟。但目前，我们还没有发现更好的竞品\n[GitHub - langgenius/dify: Dify is an open-source LLM app development platform. Dify's intuitive interface combines AI workflow, RAG pipeline, agent capabilities, model management, observability features and more, letting you quickly...](https://github.com/langgenius/dify)",
    "Tags": [],
    "ID": "46",
    "LastChange": "50",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Dify",
    "notion_page_id": "1ea0aea5-43e6-817f-b16a-f81b72c64ad7"
  },
  {
    "updated": "2025-05-05T12:51:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "The [Vercel AI](https://ai-sdk.dev/) SDK is the TypeScript toolkit designed to help developers build AI-powered applications with React, Next.js, Vue, Svelte, Node.js, and more.",
    "Tags": [],
    "ID": "45",
    "LastChange": "49",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Vercel AI SDK",
    "notion_page_id": "1ea0aea5-43e6-814b-a218-e106154e8f1b"
  },
  {
    "updated": "2025-05-05T12:30:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[**CrewAI**](https://github.com/crewAIInc/crewAI) 是一个专为构建和管理 AI 代理而设计的平台，它能让多个 AI 代理协同工作，共同完成复杂任务。我们可以将其理解为一群 AI 工作者组成的团队，每个成员都有自己的专长，并能齐心协力以达成共同目标。我们曾经在雷达中的[LLM 驱动自主代理](https://www.thoughtworks.com/zh-cn/radar/techniques/llm-powered-autonomous-agents)中提及过它。除了现有的 Python 开源库以外，CrewAI 现在还推出了企业级的解决方案，使组织可以创建基于代理的应用程序并应用于真实业务场景，在云基础设施上运行，并连接到现有的数据源（如 SharePoint 或者 JIRA）。我们已经多次使用 CrewAI 去应对生产环境中出现的问题，例如自动验证促销码，调查交易失败的原因以及处理客户支持相关的请求。在代理技术快速发展的背景下，我们对 CrewAI 的能力充满信心，因此将其归入“评估”类别。",
    "Tags": [],
    "ID": "44",
    "LastChange": "48",
    "Aliases": "",
    "Ring": "assess",
    "Name": "CrewAI",
    "notion_page_id": "1ea0aea5-43e6-8119-ba62-cf161029c5bc"
  },
  {
    "updated": "2025-05-05T12:23:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[Heroku](https://www.thoughtworks.com/zh-cn/radar/platforms/heroku) 曾是许多开发者快速发布和部署应用程序的优秀选择。近年来，我们也看到了像 [Vercel](https://www.thoughtworks.com/zh-cn/radar/platforms/vercel) 这样更现代、轻量且易用的平台的兴起，虽然它们主要面向前端应用的部署。而在全栈部署领域的一个替代选择是 [**Railway**](https://railway.com/)，这是一个云端 PaaS 平台，简化了从 GitHub/Docker 部署到生产环境可观测性的整个流程。\n\nRailway 支持大多数主流编程框架、数据库以及容器化部署。作为应用程序的长期托管平台，您可能需要仔细比较不同平台的成本。目前，我们的团队对 Railway 的部署和可观测性体验良好。其操作流畅，并且能够很好地与我们倡导的 [持续部署](https://www.thoughtworks.com/zh-cn/radar/techniques/continuous-deployment) 实践相结合。",
    "Tags": [],
    "ID": "43",
    "LastChange": "47",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Railway",
    "notion_page_id": "1ea0aea5-43e6-812f-b4e8-f5920afa64b1"
  },
  {
    "updated": "2025-05-05T12:20:00.000+00:00",
    "Quadrant": "平台",
    "Description": "类似于 [Langfuse](https://www.thoughtworks.com/zh-cn/radar/platforms/langfuse)、[Weights & Biases](https://www.thoughtworks.com/zh-cn/radar/platforms/weights-biases)和 [Arize Phoenix](https://www.thoughtworks.com/zh-cn/radar/platforms/arize-phoenix)，[**Helicone**](https://www.helicone.ai/) 是一个面向企业需求的托管 LLMOps 平台，专注于管理 LLM 成本、评估 ROI 和降低风险。作为一个开源且以开发者为中心的平台，Helicone 支持生产级 AI 应用，覆盖整个 LLM 生命周期的提示词实验、监控、调试和优化。它能够实时分析来自不同 LLM 提供商的成本、利用率、性能以及代理堆栈跟踪。虽然 Helicone 大大简化了 LLM 运维管理，但作为一个正在发展的平台，它可能需要一定的专业知识才能充分利用其先进功能。我们的团队目前正在使用该平台，并获得了良好的体验。",
    "Tags": [],
    "ID": "42",
    "LastChange": "46",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Helicone",
    "notion_page_id": "1ea0aea5-43e6-8174-99a6-cbce9ca9b0ea"
  },
  {
    "updated": "2025-05-05T12:02:00.000+00:00",
    "Quadrant": "工具",
    "Description": "尽管我们仍然推荐使用 最简特性开关，但随着团队的扩展和开发速度的加快，管理手工制作的开关变得更加 复杂。现在我们团队广泛使用 Unleash，它能够应对这种复杂性并支持 CI/CD。它既可以作为服务使用，也可 以自托管。Unleash 提供了多个语言的 SDK，拥有良好的开发者体验和友好的管理界面。尽管目前还没有对 OpenFeature 规范 的官方支持，但你可以找到由社区维护的 Go 和 Java providers。Unleash 既可以用于简 单特性开关，也支持分组和渐进式发布，使其成为适合大规模功能管理的选择。\n[Unleash: Open-Source Feature Management for Enterprises](https://www.getunleash.io/)\n[OpenFeature](https://openfeature.dev/)\n",
    "Tags": [],
    "ID": "41",
    "LastChange": "44",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Unleash",
    "notion_page_id": "1ea0aea5-43e6-8100-a6f5-d9c98a80daca"
  },
  {
    "updated": "2025-05-05T11:56:00.000+00:00",
    "Quadrant": "工具",
    "Description": "LLM（大型语言模型）像黑箱一样运作，非常难以确定它的行为。可观察性对于打开这个黑箱并理解 LLM 应用程序在生产环境中的运作至关重要。我们团队在使用 [Langfuse](https://github.com/langfuse/langfuse) 方面有过积极的体验，我们曾用它来观察、监控和评估基于 LLM 的应用程序。它的追踪、分析和评估能力使我们能够分析完成性能和准确性，管理成本和延迟，并理解生产使用模式，从而促进持续的数据驱动改进。仪器数据提供了请求-响应流和中间步骤的完整可追溯性，这可以作为测试数据，在部署新变更之前验证应用程序。我们已将 Langfuse 与 [RAG（检索增强生成）](https://www.thoughtworks.com/zh-cn/radar/techniques/retrieval-augmented-generation-rag) 等 LLM 架构，以及 [大语言模型驱动的自主代理](https://www.thoughtworks.com/zh-cn/radar/techniques/llm-powered-autonomous-agents) 一起使用。 例如，在基于 RAG 的应用程序中，分析低评分的对话追踪有助于识别架构的哪个部分（如预检索、检索或生成）需要改进。当然，在这一领域，另一个值得考虑的选项是 [Langsmith](https://www.langchain.com/langsmith)。\n\n--- Via Thought Works",
    "Tags": [],
    "ID": "40",
    "LastChange": "43",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Langfuse",
    "notion_page_id": "1ea0aea5-43e6-81da-b29e-eca0c5f2ac88"
  },
  {
    "updated": "2025-05-05T11:20:00.000+00:00",
    "Quadrant": "工具",
    "Description": "可以理解为**把原本在物理空间中使用的“团队墙”（Team Wall）虚拟化、数字化**，以适应远程协作的需求。\n\n ## ✅ 背景：团队墙的作用\n- **实体团队墙**在过去是常见的敏捷工具，如贴满便利贴的白板，显示：\n  - 用户故事（Story Cards）\n  - 任务状态（To Do / In Progress / Done）\n  - 阻碍、优先级、进度等\n- 它的价值是：**充当“信息辐射器”和“信息枢纽”**，让团队成员一眼就能掌握当前项目状态。\n\n## ⚠️ 问题：远程后信息分散\n- 随着远程办公普及，实体墙不复存在。\n- 信息散落在 Jira、Trello、Notion、Slack、邮件等不同系统中，**“一目了然”变得困难**。\n- 没有集成视图会增加沟通成本、降低协作效率。\n\n## 💡 建议：构建“统一远程团队墙”\n- 用**虚拟/数字方式重建团队墙**，比如使用一个集成仪表板，将各系统数据聚合展示。\n- 它**不是数据存储系统**，而是**统一视图的呈现层**。\n- 即便维护这面墙需要成本，比如手动同步状态，**也值得做**，因为它能恢复团队对齐感和透明度。\n\n## 🔁 仪式感：延续更新行为\n- 线下团队可能通过每日 Standup 更新实体墙。\n- 同样地，数字团队墙也可嵌入到每日会议、例会、迭代评审等“团队仪式”中。\n\n### 总结一句话：\n**“统一远程团队墙”是为了解决远程协作中信息分散的问题，通过构建一个集成视图平台，让团队像以前看实体墙一样，快速掌握任务与进度的全貌。**\n",
    "Tags": [],
    "ID": "39",
    "LastChange": "41",
    "Aliases": "",
    "Ring": "assess",
    "Name": "统一远程团队墙",
    "notion_page_id": "1ea0aea5-43e6-81bb-97a5-c23122291cf7"
  },
  {
    "updated": "2025-05-05T10:33:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "我们将 [**React Hook Form**](https://react-hook-form.com/) 视为 Formik 的替代方案。由于默认使用非受控组件，它提供了显著更好的开箱即用的表现，特别是在大型表单上。React Hook Form 很好地和各种基于 schema 的验证库（比如[Yup](https://github.com/jquense/yup), [Zod](https://github.com/colinhacks/zod) 等）进行了集成。此外 React Hook Form 提供了很大的灵活性，使其易于和现有代码库和其他库集成。你可以把 React Hook Form 和像[shadcn](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/shadcn)或者[AntD](https://ant.design/)这样的外部受控组件库一起使用。凭借出色的性能、无缝集成和活跃的开发社区，它是构建大型表单或表单密集型应用的可靠选择。",
    "Tags": [],
    "ID": "37",
    "LastChange": "40",
    "Aliases": "",
    "Ring": "assess",
    "Name": "React Hook Form",
    "notion_page_id": "1ea0aea5-43e6-8195-9f52-e2b3b2695fbd"
  },
  {
    "updated": "2025-05-05T10:32:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "[**GoFr**](https://github.com/gofr-dev/gofr) 是一个专为构建 [Golang](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/go-language) 微服务而设计的框架，通过抽象常见的微服务功能（如日志记录、追踪、指标、配置管理和 Swagger API 文档生成）来简化开发工作。它支持多种数据库，处理数据库迁移，并且能够与 Kafka 和 NATs 等消息代理进行 pub/sub 操作。此外，GoFr 还包括支持定时任务的 cron 作业功能。该框架旨在降低构建和维护微服务的复杂性，让开发者能够将更多精力集中于业务逻辑的编写，而非基础设施的管理。尽管市面上已有许多流行的 Go 库用于构建 Web API，但 GoFr 正在逐步获得关注，非常值得基于 Golang 的微服务开发团队探索和使用。",
    "Tags": [],
    "ID": "36",
    "LastChange": "39",
    "Aliases": "",
    "Ring": "assess",
    "Name": "GoFr",
    "notion_page_id": "1ea0aea5-43e6-8189-be04-c3d3bcfe5b33"
  },
  {
    "updated": "2025-05-05T12:11:00.000+00:00",
    "Quadrant": "工具",
    "Description": "目前就是用作展示组件使用，感觉比做一个测试页面来的方便，而且能起到一定的文档作用。",
    "Tags": [
      "前端",
      "交付效能"
    ],
    "ID": "35",
    "LastChange": "45",
    "Aliases": "",
    "Ring": "trial",
    "Name": "Ladle",
    "notion_page_id": "1ea0aea5-43e6-8174-9216-f801870bcb3b"
  },
  {
    "updated": "2025-05-05T09:08:00.000+00:00",
    "Quadrant": "平台",
    "Description": "https://firebase.studio/\n\nFirebase Studio accelerates your entire development lifecycle with AI agents. Build backends, front ends, and mobile apps, all in one place.",
    "Tags": [],
    "ID": "34",
    "LastChange": "37",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Firebase Studio",
    "notion_page_id": "1ea0aea5-43e6-81d0-abc2-f3078ca0a1b0"
  },
  {
    "updated": "2025-05-05T09:07:00.000+00:00",
    "Quadrant": "平台",
    "Description": "谷歌的**[Firebase](https://firebase.google.com/)**自2016年被我们纳入[无服务器架构](https://www.thoughtworks.com/zh-cn/radar/techniques/serverless-architecture)以来，发生了重大的演变。 Firebase 是一个综合性平台，可用于构建移动和Web应用，并运行在谷歌可伸缩基础设施上。我们尤其喜欢 Firebase App Distribution 和 Firebase Remote Config。前者可通过持续部署流水线，轻松发布应用程序的测试版本。而后者可以将配置更改，动态地推送给应用程序，而无须重新发布应用程序。",
    "Tags": [],
    "ID": "33",
    "LastChange": "36",
    "Aliases": "",
    "Ring": "assess",
    "Name": "FireBase",
    "notion_page_id": "1ea0aea5-43e6-810b-a48d-c80cc6ba4c71"
  },
  {
    "updated": "2025-05-05T09:05:00.000+00:00",
    "Quadrant": "技术",
    "Description": "尽管 **基础设施即代码** 是一种相对旧的技术（我们早在2011年的技术雷达中就已经介绍过它），但在现代云时代，构建基础设施的行为已经成为了将配置指令传递到云平台的重要组成部分，因此它变得非常重要。当我们说“即代码”时，是指我们在软件领域学到的所有良好实践都应应用于基础设施。使用源代码控制，遵守 [DRY原则](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)、模块化、可维护性以及使用自动化测试和部署都是关键的实践。我们当中具有深厚软件和基础设施背景的人，需要体谅和支持那些没有做过这些的同事。仅仅说“像对待代码一样处理基础设施”还不够，我们需要确保从软件世界学到的来之不易的经验教训，也能够同样应用到整个基础设施领域。",
    "Tags": [],
    "ID": "32",
    "LastChange": "35",
    "Aliases": "",
    "Ring": "assess",
    "Name": "基础设施即代码",
    "notion_page_id": "1ea0aea5-43e6-81fb-bbff-c8f262bd3f92"
  },
  {
    "updated": "2025-05-05T09:04:00.000+00:00",
    "Quadrant": "技术",
    "Description": "[DORA \\| DORA’s software delivery metrics: the four keys](https://dora.dev/guides/dora-metrics-four-keys/)\n为了度量软件交付的效能，越来越多的组织开始采用由 DORA 研究项目定义的交付核心四指标，即：更改前置 时间、部署频率、平均修复时间（MTTR）和变更失败率。这项研究及其统计分析展示了高效能交付团队和这些 指标的高度相关性，它们为衡量一个团队、甚至整个交付组织的表现提供了极佳的领先指标。\n\n虽然我们仍是这些指标的支持者，但自从我们最早开始监控它们以来，也得到了一些教训。我们也持续看到被误 导的度量方式，这些方式使用的工具仅基于持续交付（CD）流水线。在衡量稳定性指标（MTTR 和更改失败百分 比）时，仅依赖 CD 流水线数据提供的信息并不足以确定部署失败对真实用户的影响。只有包含真实事故（如用 户服务降级）的数据时，稳定性指标才有意义。\n\n与其它所有指标一样，我们建议始终牢记度量这些指标的终极目的，并使用它们反复思考和学习。例如，在花费 数周时间构建复杂仪表板工具之前，可以考虑定期在团队回顾会议当中进行[DORA 快速检查](https://dora.dev/quickcheck/)。这样的做法能够 使团队有机会思考哪些[能力](https://dora.dev/capabilities/)应被提升以改进这些指标，这比过于详细的开箱即用工具更有效。\n[DORA \\| Research](https://dora.dev/research/)",
    "Tags": [],
    "ID": "31",
    "LastChange": "34",
    "Aliases": "",
    "Ring": "assess",
    "Name": "交付核心四指标",
    "notion_page_id": "1ea0aea5-43e6-81e2-a0b8-d17676a822d9"
  },
  {
    "updated": "2025-05-05T09:03:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[**Grafana Loki**](https://grafana.com/docs/loki/)是一个受 Prometheus 启发的横向可扩展，高可用的多租户日志聚合系统。Loki 只对日志的元数据进行索引，并把它当做日志流的标签集，而日志数据本身则储存在像 S3, GCS 或 Azure Blob Storage 这样的块存储方案中。这样做的好处是 Loki 比竞争对手的运维复杂度更低，同时也降低了存储成本。正如你所期待的那样，它与 Grafana 和[Grafana Alloy](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/grafana-alloy)深度集成，即使其他的日志采集机制也被支持。\n\nLoki 3.0 引入了对原生[OpenTelemetry](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/opentelemetry)的支持，这使得与 OpenTelemetry 系统的数据摄入与集成如配置一个端点一样简单。此外，它还提供了高级的多租户功能，例如通过 shuffle-sharding 的方式实现各租户间的隔离，避免异常的租户(比如正在执行高负载查询或者出现故障)影响到集群中的其他租户。如果你还没有关注 Grafana 生态系统的最新发展，现在正是个好时机——它正在快速地演进。",
    "Tags": [],
    "ID": "30",
    "LastChange": "33",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Grafana Loki",
    "notion_page_id": "1ea0aea5-43e6-8113-9908-ff561da18d3e"
  },
  {
    "updated": "2025-05-05T09:02:00.000+00:00",
    "Quadrant": "工具",
    "Description": "前身为 Grafana Agent，[**Grafana Alloy**](https://grafana.com/docs/alloy/latest/) 是一个开源的 [OpenTelemetry](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/opentelemetry) Collector。Alloy 被设计为一个一体化的遥测数据收集器，用于收集包括日志、指标和跟踪在内的所有遥测数据。它支持常用的遥测数据格式，如 OpenTelemetry、[Prometheus](https://www.thoughtworks.com/zh-cn/radar/tools/prometheus) 和 Datadog。随着 [Promtail 最近被弃用](https://grafana.com/docs/loki/latest/send-data/promtail/)，Alloy 正逐渐成为遥测数据收集的首选工具——特别是在使用 Grafana 可观察性技术栈时，用于日志数据的收集。",
    "Tags": [],
    "ID": "29",
    "LastChange": "32",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Grafana Alloy",
    "notion_page_id": "1ea0aea5-43e6-81ea-86a5-cf29fe05e825"
  },
  {
    "updated": "2025-05-05T09:01:00.000+00:00",
    "Quadrant": "技术",
    "Description": "在提示生成中，最大的挑战之一是确保 AI 工具能够访问与任务相关的所有上下文信息。这些上下文信息通常已经存在于我们每天使用的系统中，如维基、问题追踪器、数据库或可观察性系统。AI 工具与这些信息源的无缝集成可以显著提高 AI 生成输出的质量。\n\n[**模型上下文协议**](https://github.com/modelcontextprotocol)（MCP）是由 Anthropic 发布的开放标准，提供了一个标准化的框架，用于将 LLM 应用与外部数据源和工具集成。它定义了 MCP 服务器和客户端，服务器访问数据源，客户端则集成并使用这些数据来增强提示。许多编码助手已经实现了 MCP 集成，使其能够作为 MCP 客户端运行。MCP 服务器可以通过两种方式运行：本地运行，作为在用户机器上运行的 Python 或 Node 进程；或者远程运行，作为通过 SSE 连接的服务器（尽管我们尚未看到远程服务器的使用）。目前，MCP 主要以第一种方式使用，开发者通过克隆开源的 [MCP](https://mcpservers.org/) [服务器](https://mcp.so/) [实现](https://smithery.ai/) 来使用它。虽然本地运行的服务器提供了一种避免第三方依赖的简洁方式，但它们对于非技术用户仍然不够友好，并且带来了治理和更新管理等挑战。尽管如此，可以预见这一标准未来可能会发展成一个更成熟、更易于用户使用的生态系统。",
    "Tags": [],
    "ID": "28",
    "LastChange": "31",
    "Aliases": "",
    "Ring": "assess",
    "Name": "MCP",
    "notion_page_id": "1ea0aea5-43e6-81a6-a39a-c44723bd02f8"
  },
  {
    "updated": "2025-05-05T09:00:00.000+00:00",
    "Quadrant": "平台",
    "Description": "[**Supabase**](https://supabase.com/) 是一个开源的 [Firebase](https://www.thoughtworks.com/zh-cn/radar/platforms/firebase) 替代方案，用于构建可扩展且安全的后端。它提供了一整套集成服务，包括 PostgreSQL 数据库、认证、即时 API、Edge Functions、实时订阅、存储以及向量嵌入。 Supabase 的目标是简化后端开发，使开发者能够专注于构建前端体验，同时利用开源技术的强大功能和灵活性。与 Firebase 不同，Supabase 基于 PostgreSQL 构建。如果您正在进行原型设计或开发 MVP（最小可行产品），Supabase 值得考虑，因为在原型阶段之后，它更容易迁移到其他 SQL 解决方案。\n",
    "Tags": [],
    "ID": "27",
    "LastChange": "30",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Supabase",
    "notion_page_id": "1ea0aea5-43e6-813f-9b8a-c748260ed8ed"
  },
  {
    "updated": "2025-05-05T08:58:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Graph databases store information as arbitrarily interconnected nodes linked by named relations, rather than as tables and joins. Schema-less and highly extensible, they are an excellent choice for modelling semi-structured data in complex domains. Neo4j is the front-runner in the space both its REST API and its Cypher query language support simple and fast storage and traversal of graphs.",
    "Tags": [],
    "ID": "26",
    "LastChange": "29",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Neo4j",
    "notion_page_id": "1ea0aea5-43e6-812e-bd44-c40c03b52546"
  },
  {
    "updated": "2025-05-05T08:57:00.000+00:00",
    "Quadrant": "工具",
    "Description": "JavaScript的世界日新月异，随着我们使用框架的经验越来越多，我们的倾向也在改变。我们深入使用某些框架，其他备选框架自然黯然失色。在React前端测试方面，**[React Testing Library](https://testing-library.com/)**就是这样一个例子。我们团队很喜欢的是，用这个框架写的测试比其他框架(如 [Enzyme](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/enzyme))更健壮，因为它鼓励独立测试组件间的关系，而不是测试全部实现细节。 这种思维源自于[测试库](https://testing-library.com/)，React Testing Library 是它的一部分，它还为像[Angular](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/angular) 和 [Vue.js](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/vue-js)这样的框架提供了一整套库。",
    "Tags": [],
    "ID": "25",
    "LastChange": "28",
    "Aliases": "",
    "Ring": "assess",
    "Name": "React Testing Library",
    "notion_page_id": "1ea0aea5-43e6-8160-97fb-d6f75acbaf7d"
  },
  {
    "updated": "2025-05-05T08:57:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "**[React Hooks](https://reactjs.org/docs/hooks-intro.html)** 引入了一种管理状态逻辑的新方法；鉴于React组件相比较类来说更接近于函数，Hooks接受了这一点并将状态传给函数，而不是将函数作为方法传给带有状态的类。React应用中状态管理的另一个主要内容是 [Redux](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/redux) ，我们注意到它已经受到审查，可以看到，在某些时候Redux的复杂性并不值得，对于这些情况，使用Hooks的简单方法是更可取的。完全靠自己去引入这种实现很快会变得棘手；因此我们推荐考虑结合 [React Context](https://reactjs.org/docs/context.html) 以及useContext和useReducer Hooks，并根据这篇 [博客文章](https://blog.logrocket.com/guide-to-react-usereducer-hook/) 中解释的路线来实现。",
    "Tags": [],
    "ID": "24",
    "LastChange": "27",
    "Aliases": "",
    "Ring": "assess",
    "Name": "React Hooks",
    "notion_page_id": "1ea0aea5-43e6-8110-9c99-dd6a868e496a"
  },
  {
    "updated": "2025-05-05T08:56:00.000+00:00",
    "Quadrant": "工具",
    "Description": "Ruff 是一个新的 Python linter。使用 linter 是毋庸置疑的，只需要考虑具体要使用哪一个。Ruff 能够脱颖而 出有两个原因：开箱即用的体验，以及性能。其中内置了 500 多条规则，可以轻松取代 Flake8 和它的许多插件。 我们的经验证实了 Ruff 团队对其性能的说法。实际上，它的速度至少比其它 linter 快出一个数量级，这是一个 巨大的优势，有助于减少大型代码库的构建时间。基于上述原因，Ruff 已成为我们实施 Python linter 的默认 选择。\n[GitHub - astral-sh/ruff: An extremely fast Python linter and code formatter, written in Rust.](https://github.com/astral-sh/ruff)",
    "Tags": [],
    "ID": "23",
    "LastChange": "26",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Ruff",
    "notion_page_id": "1ea0aea5-43e6-81a4-ac03-f2ceabb20aae"
  },
  {
    "updated": "2025-05-05T08:55:00.000+00:00",
    "Quadrant": "工具",
    "Description": "Mermaid 通过使用类似 Markdown 的标记语言来生成图表。自从上次在技术雷达中介绍以来，Mermaid 添加 了对更多图表和与源代码存储库、集成开发环境和知识管理工具集成的支持。 值得注意的是，它在 GitHub 和 GitLab 等流行源代码存储库中得到原生支持，从而可以在 Markdown 文档中嵌入并轻松更新 Mermaid 图表。 我们的许多团队都倾向于使用 Mermaid 作为他们的图表即代码工具，因为它易于使用、集成广泛，且支持的图 表类型不断增多。\n[Mermaid \\| Diagramming and charting tool](https://mermaid.js.org/)\n[Integrations \\| Mermaid](https://mermaid.js.org/ecosystem/integrations-community.html)",
    "Tags": [],
    "ID": "22",
    "LastChange": "25",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Mermaid",
    "notion_page_id": "1ea0aea5-43e6-81c9-84a0-eec298e81873"
  },
  {
    "updated": "2025-05-05T08:54:00.000+00:00",
    "Quadrant": "工具",
    "Description": "AI 辅助编程工具的竞赛仍在继续，而其中最引人注目的一个就是 Cursor。Cursor 是一个以 AI 为核心的代码 编辑器，旨在通过深度整合 AI 到编码工作流中来提升开发者的生产力。虽然我们在之前的雷达评估中已经关注 到它，但显然，Cursor 近期的持续改进已为其带来了质的飞跃。在我们的使用中，Cursor 展现了基于现有代 码库的强大上下文推理能力。尽管其他 AI 代码工具如 GitHub Copilot 已经可以围绕代码片段进行代码生成或 协作，Cursor 的多行和多文件编辑操作让它脱颖而出。Cursor 是基于 VSCode 代码库分叉开发的，提供了一 种符合开发者直觉的快速且直观的交互方式。通过快捷键 ctrl/cmd+K 和 ctrl/cmd+L 即可完成强大的操作。 Cursor 在 AI 编程工具的竞赛中引领了新一轮的竞争，尤其是在开发者交互和代码库理解方面更为突出。\n[Cursor - The AI Code Editor](https://www.cursor.com/)",
    "Tags": [],
    "ID": "21",
    "LastChange": "24",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Cursor",
    "notion_page_id": "1ea0aea5-43e6-81ae-9182-c6de804a750b"
  },
  {
    "updated": "2025-05-05T08:53:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[ESLint](https://eslint.org/)作为JavaScript的代码检查工具，它提供了很多规则集、推荐规则和插件，可以扩展为不同的框架或JavaScript风格。通过在开发时对代码进行实时分析，Eslint可以极大地帮助团队在开发过程中建立和遵循代码规范。Eslint不仅可以通过实施最佳实践和代码规范，对编码实践进行标准化，还能识别代码中的漏洞。这是因为ESLint与大多数IDE都能很好地集成，并可以在编码过程中提供实时反馈。特别是它的样式规则可以自动修复代码错误，持续有效并且不会产生额外的开发成本。ESlint社区的文档很好地解释了它的编码模式，可以帮助开发人员快速掌握规则。随着ESLint变得越来越通用和强大，它已经被行业所认可。例如[TypeScript](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/typescript)团队就选择支持ESLint并与其合作，而非TSLint。",
    "Tags": [],
    "ID": "20",
    "LastChange": "23",
    "Aliases": "",
    "Ring": "assess",
    "Name": "ESLint",
    "notion_page_id": "1ea0aea5-43e6-812f-908a-fe7aff4bcc90"
  },
  {
    "updated": "2025-05-05T08:53:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "",
    "Tags": [],
    "ID": "19",
    "LastChange": "22",
    "Aliases": "",
    "Ring": "assess",
    "Name": "TypeScript",
    "notion_page_id": "1ea0aea5-43e6-8103-8878-ff596a7db99e"
  },
  {
    "updated": "2025-05-05T08:51:00.000+00:00",
    "Quadrant": "工具",
    "Description": "[**v0**](https://v0.dev/) 是由 Vercel 开发的一款 AI 工具，可根据截图、Figma 设计或简单的提示生成前端代码。它支持包括 [React](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/react-js)、[Vue](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/vue-js)、[shadcn](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/shadcn) 和 [Tailwind](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/tailwind-css) 在内的多种前端框架。除了 AI 生成代码的功能之外，v0 还提供了出色的用户体验，包括预览生成的代码并一步部署到 Vercel 的能力。尽管构建真实世界的应用程序通常需要集成多个功能，不仅仅局限于单个界面，但 v0 为原型设计提供了一个稳固的工具，并可作为开发复杂应用程序的起点初始化代码。",
    "Tags": [],
    "ID": "18",
    "LastChange": "21",
    "Aliases": "",
    "Ring": "assess",
    "Name": "v0",
    "notion_page_id": "1ea0aea5-43e6-8162-a493-ed8680df725c"
  },
  {
    "updated": "2025-05-05T08:31:00.000+00:00",
    "Quadrant": "工具",
    "Description": "不论是对设计师，还是多角色团队而言，**[Figma](https://www.figma.com/)** 都已被证明是协作设计的首选工具。它允许开发人员和其他角色通过浏览器查看和评论设计，而无需使用桌面版本。和它的竞争对手（如Invision 或 Sketch）相比，Figma 将版本控制、协作设计和设计分享这些功能都集中到一个工具上，这使得我们的团队更容易一起想出新点子。除了实时设计和协作功能外，Figma 还提供了一个 API 以帮助改善 [DesignOps](https://www.thoughtworks.com/zh-cn/radar/techniques/designops) 流程 。",
    "Tags": [],
    "ID": "17",
    "LastChange": "20",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Figma",
    "notion_page_id": "1ea0aea5-43e6-81d2-866f-d149a817d877"
  },
  {
    "updated": "2025-05-05T05:15:00.000+00:00",
    "Quadrant": "平台",
    "Description": "Edge Functions\n通过内容交付网络（CDNs）进行去中心化代码执行的可用性和使用量正在增长。诸如 Cloudflare Workers 或 Amazon CloudFront Edge Functions 这样的服务提供了一种机制，可以在靠近客户地理位置的地方执行无服务器代码片段。 边缘函数不仅可以在边缘生成响应时提供更低的延迟，还可以在请求和响应从区域服务器出发和返回的途中，以特定位置的方式重写它们。例如，你可能会重写请求的 URL， 以路由到一个特定服务器，该服务器拥有与请求正文中找到的字段相关的本地数据。这种方法最适合于短暂、快 速运行的无状态处理，因为边缘的计算能力是有限的。\n[Edge Functions](https://aws.amazon.com/developer/application-security-performance/articles/cloudfront-edge-functions/)\n[Cloudflare Workers \\| Technology Radar \\| Thoughtworks China](https://www.thoughtworks.com/cn/radar/platforms/cloudflare-workers)\n",
    "Tags": [],
    "ID": "16",
    "LastChange": "19",
    "Aliases": "",
    "Ring": "assess",
    "Name": "边缘函数",
    "notion_page_id": "1ea0aea5-43e6-8196-9b2d-c8cf15d32a89"
  },
  {
    "updated": "2025-05-05T05:13:00.000+00:00",
    "Quadrant": "技术",
    "Description": "我们遗憾地发现，人们很少使用[特性开关](https://martinfowler.com/articles/feature-toggles.html)，且经常混淆其类型和使用场景。为了从[持续集成](https://martinfowler.com/articles/continuousIntegration.html)中受益，一些团队会使用 [LaunchDarkly](https://launchdarkly.com/) 等重量级平台来实现特性切换（包括发布切换），即使他们所需要的仅仅是简单地 if/else 条件控制。 因此，除非你需要 A/B 测试、[金丝雀发布](https://martinfowler.com/bliki/CanaryRelease.html)或将特性发布的职责交给业务人员，我们建议使用 **最简特性开关** 来代替不必要的复杂的特性切换框架。",
    "Tags": [],
    "ID": "15",
    "LastChange": "18",
    "Aliases": "",
    "Ring": "assess",
    "Name": "最简特性开关",
    "notion_page_id": "1ea0aea5-43e6-81c4-8963-fb5339537771"
  },
  {
    "updated": "2025-05-05T04:33:00.000+00:00",
    "Quadrant": "技术",
    "Description": "引入[微服务](https://martinfowler.com/articles/microservices.html)令我们受益匪浅，使用微服务，团队可以扩展那些独立部署及维护的服务的交付。遗憾的是，我们也看到许多团队创建了单体前端——一个建立在后端服务之上的大而混乱的浏览器应用程序——这在很大程度上抵消了微服务带来的好处。自从问世以来， **微前端** 持续变得流行。我们已经看到，许多团队采用这种架构的某种形式，来管理多开发人员和多团队的复杂性，以提供相同的用户体验。在去年的六月份，这个技术的发起人之一，发表了一篇[介绍性的文章](https://martinfowler.com/articles/micro-frontends.html)，可以起到微前端参考文献的作用。它展示了这种设计是如何通过各种Web编程机制实现的，以及使用[React.js](https://www.thoughtworks.com/zh-cn/radar/languages-and-frameworks/react-js)构建了一个示例应用程序。我们有理由相信，随着大型组织尝试在跨多团队中分解UI开发，这种风格将越来越流行。\n\n-- Via Thought Works",
    "Tags": [],
    "ID": "14",
    "LastChange": "17",
    "Aliases": "",
    "Ring": "assess",
    "Name": "微前端",
    "notion_page_id": "1ea0aea5-43e6-8113-aef1-eb8d2e14df22"
  },
  {
    "updated": "2025-05-05T04:32:00.000+00:00",
    "Quadrant": "技术",
    "Description": "在迭代速度快、用户需求不断演进的产品开发环境中，设计是一个不断变化的领域。这意味着对设计决策输入需求会一直持续下去。借鉴了用 ADR（架构决策记录）记录软件架构决策的思路，采用类似的格式，以设计系统决策记录来记录设计系统决策以及相应的依据、研究洞见和实验结果，这有效地传达了设计系统决策似乎已成为产品开发团队新的需求。这种轻量级的方式也被 zeroheight 推荐。这一方法可以减少新人上手时间，推动讨论的进行。\n[Capturing your design system decisions](https://zeroheight.com/blog/capturing-your-design-system-decisions/)",
    "Tags": [],
    "ID": "13",
    "LastChange": "16",
    "Aliases": "",
    "Ring": "assess",
    "Name": "设计系统决策记录",
    "notion_page_id": "1ea0aea5-43e6-8144-94ad-f091c4a40a5a"
  },
  {
    "updated": "2025-05-05T04:30:00.000+00:00",
    "Quadrant": "技术",
    "Description": "随着应用开发变得越来越动态和复杂，交付风格一致且好用的产品成为了一项挑战，尤其是在有多个团队参与 不同产品开发的大型组织中。设计系统定义了一系列的设计模式、组件库以及良好的设计和工程实践，以确保 数字产品的一致性。设计系统从过去的企业风格指南演变而来，提供易于查找和使用的共享组件库和文档。通常，设计系统的风格指南以代码的形式记录并进行版本控制，比简单的文档记录更加清晰且易于维护。设计系统已经成为跨团队和学科进行产品开发时的标准方法，每当需要新的视觉组件时，团队不用重新发明轮子，因此能够集中精力，专注解决产品本身的种种挑战。\n\n我们的经验表明，团队在构建设计系统时很少采用产品为中心的思维方式。共享组件库和文档的主要消费者是产品开发团队。在使用产品为中心的思维方式时，设计系统所有者应该与消费者（开发团队）合作，建立共情。 我们发现，许多组件库之所以受到批评，是因为所有者团队无法快速响应消费者的需求，并且无法接受来自外 部的贡献。产品为中心的思维方式还要求组织思考是否应该允许和怎样向设计系统做出贡献，以及如何管理这 些贡献——在这个话题上，我们推荐采用设计系统决策记录。对我们来说，维护一个良好的设计系统或组件库 不光是技术工作，也同样是社交工作\n\n[设计系统决策记录 \\| Technology Radar \\| Thoughtworks China](https://www.thoughtworks.com/zh-cn/radar/techniques/design-system-decision-records)",
    "Tags": [],
    "ID": "12",
    "LastChange": "15",
    "Aliases": "",
    "Ring": "assess",
    "Name": "设计系统",
    "notion_page_id": "1ea0aea5-43e6-8115-b1fa-e90bc7a982dd"
  },
  {
    "updated": "2025-05-05T03:45:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "https://mdxjs.com/\nMDX lets you use JSX in your markdown content. You can import components, such as interactive charts or alerts, and embed them within your content. This makes writing long-form content with components a blast.",
    "Tags": [],
    "ID": "11",
    "LastChange": "14",
    "Aliases": "",
    "Ring": "assess",
    "Name": "MDX",
    "notion_page_id": "1ea0aea5-43e6-8153-aabd-d623ba290044"
  },
  {
    "updated": "2025-05-05T03:36:00.000+00:00",
    "Quadrant": "技术",
    "Description": "**Fuzz 测试** ，或称模糊测试，是一种已经存在很长时间但仍然较少被广泛了解的测试技术。其目标是向软件系统输入各种无效数据并观察其行为。例如，对于一个 HTTP 端点，错误的请求通常应返回 4_xx_ 错误，但 fuzz 测试往往会引发 5_xx_ 错误甚至更严重的问题。随着工具的完善以及文档支持的增强，fuzz 测试在如今显得尤为重要，尤其是在更多 AI 生成代码和[自满于 AI 生成的代码](https://www.thoughtworks.com/zh-cn/radar/techniques/complacency-with-ai-generated-code)的背景下。因此，现在是采用 fuzz 测试的好时机，以确保代码的健壮性和安全性。",
    "Tags": [],
    "ID": "10",
    "LastChange": "12",
    "Aliases": "",
    "Ring": "assess",
    "Name": "模糊测试",
    "notion_page_id": "1ea0aea5-43e6-8120-9264-cf587e82c414"
  },
  {
    "updated": "2025-05-05T02:39:00.000+00:00",
    "Quadrant": "平台",
    "Description": "大多数用于构建购物网站的电子商务解决方案通常会陷入 80/20 陷阱，即我们可以轻松构建 出 80% 的需求，但对于剩下的 20% 却无能为力。Medusa 提供了一个良好的平衡。它是一个高度可定制的 开源商业平台，允许开发人员创建独特且量身定制的购物体验，可以自我托管或运行在 Medusa 的平台上。 Medusa 基于 Next.js 和 PostgreSQL 构建，通过提供从基本购物车和订单管理到高级功能（如礼品卡模块和 不同地区的税收计算）的全面模块，加快了开发过程。\n[World's most flexible commerce platform](https://medusajs.com/)",
    "Tags": [],
    "ID": "9",
    "LastChange": "10",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Medusa",
    "notion_page_id": "1ea0aea5-43e6-814e-8845-d94442f3617a"
  },
  {
    "updated": "2025-05-05T01:53:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "Lenis 是一个为现代浏览器设计的轻量且强大的平滑滚动库。 它能够实现流畅的滚动体验，例如 WebGL 滚动同步和视差效果，这使其非常适合那些需要构建流畅、无缝滚动交互页面的团队。它提供了一种精简高效的方式来创建平滑滚动效果。然而，该库在无障碍性方面可能存在一些问题，特别是在处理垂直和水平滚动交互时，可能会让残障用户感到困惑。虽然它在视觉上很吸引人，但在实现时仍然需要仔细考虑无障碍性\n[Lenis – Get smooth or die trying](https://lenis.darkroom.engineering/)\n",
    "Tags": [],
    "ID": "8",
    "LastChange": "9",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Lenis",
    "notion_page_id": "1ea0aea5-43e6-81c4-ac93-ca503b356cc2"
  },
  {
    "updated": "2025-05-05T01:16:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "shadcn 通过提供可重用的、可直接复制粘贴的组件，挑战了传统组件库的概念。这种方法让团队拥有完整的控制权和所有权，更加容易进行定制和扩展，而这是更受欢迎的传统库如 MUI 和 Chakra UI 往往不足的地方。 shadcn 使用 Radix UI 和 Tailwind CSS 构建，能够无缝集成到任何基于 React 的应用程序中，非常适合优先 考虑控制和可扩展性的项目。它还提供一个 CLI，帮助将组件复制并粘贴到项目中。其优点还包括减少隐藏依 赖关系，避免紧耦合的实现，因此对于寻求更加自主且可适应的前端开发方法的团队来说，shadcn 正在成为一 个引人注目的替代方案。\n\n[Build your component library - shadcn/ui](https://ui.shadcn.com/)",
    "Tags": [],
    "ID": "7",
    "LastChange": "8",
    "Aliases": "",
    "Ring": "assess",
    "Name": "shadcn",
    "notion_page_id": "1ea0aea5-43e6-814e-b1ec-f66b8886cb21"
  },
  {
    "updated": "2025-05-05",
    "Quadrant": "平台",
    "Description": "Kubernetes 是一个开源容器编排平台，用于自动部署、扩展和管理容器化应用，支持高可用与弹性伸缩。",
    "Tags": [],
    "ID": "6",
    "LastChange": "7",
    "Aliases": "",
    "Ring": "assess",
    "Name": "Kubernetes",
    "notion_page_id": "1ea0aea5-43e6-8114-8983-d37eca7162db"
  },
  {
    "updated": "2025-05-05T11:23:00.000+00:00",
    "Quadrant": "技术",
    "Description": "“1%金丝雀”是一种精细化的金丝雀发布策略（Canary Release Strategy），本质上是将新版本或新功能仅推送给一个极小比例的用户（如1%），作为一种风险最小化的试验手段。\n\n“1%金丝雀”是金丝雀发布的极小规模变种，通常指：\n- 仅向1%的真实用户发布新功能\n- 用户群体按**不同维度代表性（国家、设备、活跃度、使用场景等）**进行精心抽样\n- 作为真实环境中的探测器，验证功能在有限曝光下的可用性与风险\n\n实践需要的配置：\n| 项目             | 建议做法                           |\n|------------------|------------------------------------|\n| 目标用户选择     | 精选样本（按地域、终端、版本等）     |\n| 可观察性工具     | 接入 APM（如Datadog、Prometheus） |\n| 自动回滚机制     | 错误率超阈值即停止发布              |\n| 变更监控指标     | 崩溃率、延迟、核心路径点击变化等     |\n| 用户反馈渠道     | 引导反馈、埋点、客服协同等           |\n",
    "Tags": [
      "交付效能",
      "测试与质量"
    ],
    "ID": "5",
    "LastChange": "42",
    "Aliases": "",
    "Ring": "assess",
    "Name": "1%金丝雀",
    "notion_page_id": "1e90aea5-43e6-819a-91ad-fccb7068935d"
  },
  {
    "updated": "2025-05-04",
    "Quadrant": "语言与框架",
    "Description": "D3 是一个基于数据驱动文档的 JavaScript 库，用于构建动态、交互式的数据可视化图表，支持高度定制与 DOM 操作。",
    "Tags": [],
    "ID": "4",
    "LastChange": "4",
    "Aliases": "",
    "Ring": "assess",
    "Name": "D3",
    "notion_page_id": "1e90aea5-43e6-813d-87e3-f9e8408a9300"
  },
  {
    "updated": "2025-05-05T03:39:00.000+00:00",
    "Quadrant": "工具",
    "Description": "- [**D2**](https://github.com/terrastruct/d2) 是一个开源的[图表即代码](https://www.thoughtworks.com/zh-cn/radar/techniques/diagrams-as-code)工具，帮助用户通过文本创建和定制图表。它引入了 [D2 图表脚本语言](https://d2lang.com/tour/intro)，以简单的声明式语法优先保证可读性而非紧凑性。\n- [Icon for D2](https://icons.terrastruct.com/)\n\n",
    "Tags": [],
    "ID": "3",
    "LastChange": "13",
    "Aliases": "",
    "Ring": "assess",
    "Name": "D2",
    "notion_page_id": "1e90aea5-43e6-8157-895a-e1efda176091"
  },
  {
    "updated": "2025-05-05T03:23:00.000+00:00",
    "Quadrant": "语言与框架",
    "Description": "React普及率非常高,不少AI编程平台都默认使用React(v0, Firebase Studio)",
    "Tags": [],
    "ID": "2",
    "LastChange": "11",
    "Aliases": "",
    "Ring": "trial",
    "Name": "React",
    "notion_page_id": "1e90aea5-43e6-8195-93c6-fe677be34fac"
  },
  {
    "updated": "2025-05-05",
    "Quadrant": "技术",
    "Description": "技术雷达是一种技术管理工具，用于跟踪、评估和可视化团队采用新技术的状态与演进过程。",
    "Tags": [],
    "ID": "1",
    "LastChange": "6",
    "Aliases": "",
    "Ring": "trial",
    "Name": "技术雷达",
    "notion_page_id": "1e90aea5-43e6-802f-bfed-c07d521107d9"
  }
]